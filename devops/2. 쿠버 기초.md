# 쿠버 기초

 90 ~ 153



1. 마스터 노드

   - 설정하기

   ```
   vi install.sh
   
   sudo apt-get update && sudo apt-get install -y apt-transport-https curl
   curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
   cat <<EOF | sudo tee /etc/apt/sources.list.d/k
   ubernetes.list
   deb https://apt.kubernetes.io/ kubernetes-xenial main
   EOF
   sudo apt-get update
   sudo apt-get install -y kubelet kubeadm kubectl
   sudo apt-mark hold kubelet kubeadm kubectl
   
   저장 후 
   
   bash install.sh
   
   설치 후
   
   sudo kubeadm init
   sudo swapoff -a
   sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab 
   
   노드 초기화 후 나오는 메세지 중 아래 실행
   
   mkdir -p $HOME/.kube
   sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
   sudo chown $(id -u):$(id -g) $HOME/.kube/config
   
   중요! Pod Network 추가
   kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"
   
   ```

2. 슬레이브 노드 

   - 설정하기

   ```
   1. 도커를 설치한다
   2. 마스터 노드에서 쿠버네티스를 설치한 것과 동일하게 설치한다.
   3. init 명령어 전까지만 수행한다.
   
   마스터에서 init 후 나온 다음과 같은 메시지로 워커 노드를 참가 시킨다.
   
   sudo kubeadm join 10.0.2.15:6443 --token xwvbff.5xc67j8qc6ohl2it \
   --discovery-token-ca-cert-hash
   sha256:e19e9263aeb2340a602c2057966b71551e01a5e287d3f23b05073c7b248932e1
   ```

   

3. 쿠버네티스 명령어

   - 연결된 노드들의 상태를 확인

   ```
   kubectl get nodes
   ```

   - 간단한 애플리케이션 실행 및 확인

   ```
   kubectl create deploy --image=nginx
   kubectl get pod
   kubectl port-forward nginx-XXXXXXXXXX-XXXXX 8080:80
   ```

   - 포드 확인

   ```
   kubectl get pods
   ```

   - 서비스 확인

   ```
   kubectl get services
   ```

   - 애플리케이션 수평 스케일링

   ```
    kubectl scale deploy http-go --replicas=3
   ```

   - 디플로이 확인

   ```
    kubectl get deploy
   ```

   - 직접 앱에 접근하기

   ```
   kubectl get pods 로 아이피 확인
   kubectl exec http-go-XXXXXX-bt4xq -- curl -s http://10.109.140.155:8080
   ```

   - 앱의 위치 확인

   ```
   kubectl get pod -o wide
   ```

   - 포드의 자세한 내용 살펴보기

   ```
   kubectl describe pod http-go-XXXXXX-bt4xq
   ```

   - 모든 서비스 지우기

   ```
   kubectl delete all --all
   ```

   - 쿠버니테스 주요 컴포넌트 확인하기

   ```
    kubectl get pod -n kube-system
   ```

   

4.  쿠버네티스에 앱 실행해보기

   - go 언어로 main.go 작성

   ```
   package main
   
   import (
           "fmt"
           "github.com/julienschmidt/httprouter"
           "net/http"
           "log"
           "os"
   )
   
   func Index(w http.ResponseWriter, r *http.Request, _ httprouter.Params){
           hostname,err:=os.Hostname()
           if err == nil {
                   fmt.Fprint(w,"Welcome! " + hostname +"\n")
           } else{
                   fmt.Fprint(w, "Welcome! Error\n")
           }
   }
   
   func main() {
           router := httprouter.New()
           router.GET("/",Index)
   
           log.Fatal(http.ListenAndServe(":8080",router))
   }
   ```

   - Go 언어 설치 및 빌드

   ```
   apt install golang
   go get github.com/julienschmidt/httprouter
   go build main.go
   
   ./main
   
   외부에서 접속해서 확인
   
   ```

   - dockerfile 작성

   ```
   FROM golang:1.11
   WORKDIR /usr/src/app
   COPY main /usr/src/app
   CMD ["/usr/src/app/main"]
   ```

   - 컨테이너 이미지 만들기

   ```
   docker build -t http-go
   ```

   - 컨테이너 실행해서 확인

   ```
   docker run -d -p 8080:8080 --rm http-go
   ```

   - 도커허브에 컨테이너 푸시하기

   ```
   docker tag http-go dalgudcks/http-go
   docker login
   
   docker push dalgudcks/http-go
   ```

   - 명령어에 몇 가지 옵션으로 디스크립션을 간단히 전달하여 한줄로 앱을 실행

   ```
    kubectl create deploy http-go --image=dalgudcks/http-go
   ```

   - 로드밸런서라는 서비스를 작성하여 외부 로드 밸런서를 생성한다. 

   ```
    kubectl expose deployment http-go --type=LoadBalancer --name http-go-svc --port=8080 --target-port=8080
   
   kubectl get services
   ```
   
- 앱에 접근하기
   
```
   kubectl exec http-go-XXXXXX-bt4xq -- curl -s http://10.109.140.155:8080
   
   curl 명령어로 요청
   external IP를 할당 받지 못했기 때문에 포드의 힘을 빌려 요청한다.
   ```
   




### etcd



### Pod

- yaml로 포드 디스크립터 만들기

  포드 정의

  1. apiVersion: 쿠버네티스 api의 버전을 가리킴
  2. kind: 어떤 리소스 유형인지 결정(포드 레플리카컨트롤러, 서비스 등)
  3. 메타데이터: 포드와 관련된 이름, 네임스페이스, 레이블, 그 밖의 정보 존재
  4. 스펙: 컨테이너, 볼륨 등의 정보
  5. 상태: 포드의 상태, 각 컨테이너의 설명 및 상태, 포드 내부의 IP 및 그 밖의 기본 정보 등



- 포드에서 YAML 파일 불러오기

  - ```
    kubectl get pod http-go -o yaml
    ```

- 디스크립터 작성하기

  - ```
    http-go-pod.yaml
    
    # 이 디스크립터는 쿠버네티스 API v1를 사용
    apiVersion: v1
    # 리소스 포드에 대한 설명
    kind: Pod
    metadata:
    # 포드의 이름
    name: http-go
    spec:
    containers:
    # 생성할 컨테이너의 컨테이너 이미지
    - image: gasbugs/http-go
    name: http-go
    ports:
    # 응답 대기할 애플리케이션 포트
    - containerPort: 8080
    protocol: TCP
    ```

  - kubectl에 디스크립터 작성 요령 확인 가능

    ```
    kubectl explain pods
    ```

  - 디스크립터를 사용해 포드 생성

    ```
    kubectl create -f http-go-pod.yaml
    ```

  - kubectl log로 포드의 로그 가져오기

    ```
    kubectl logs http-go
    ```

  - 컨테이너에서 호스트로 포트 포워딩

    - 디버깅 혹은 다른 이유로 서비스를 거치지 않고 특정 포드와 통신하고 싶을 때 사용
    -  kubectl port-forward 명령으로 수행

    ```
    kubectl port-forward http-go 8080:8080
    Forwarding from 127.0.0.1:8888 -> 8080
    
    #컨테이너 8888 포트를 pod의 8080 포트로 전달
    
    bg
    curl 127.0.0.1:8888
    ```

  - 포드에 주석 추가하기

    - 각 포드나 API 객체 설명이 추가
    - 클러스터를 사용하는 모든 사람이 각 객체의 정보를 빠르게 확인 가능
    - 예를 들어 객체를 만든 사람의 이름을 지정
    - 공동 작업 가능
    - 총 256KB까지 포함 가능

    ```
     kubectl annotate pod http-go key="test1234"
    
     kubectl get pod http-go -o yaml #확인
    ```

  - 포드 삭제

    ```
    kubectl delete pod <포드 이름>
    
    kubectl get pod 로 조회
    
    kubectl delete pod --all
    ```

    





## Namespaces

- 리소스를 각각의 분리된 영역으로 나누기 좋은 방법
- 여러 네임스페이스를 사용하면 복잡한 쿠버네티스 시스템을 더 작은 그룹으로 분할
- 멀티 테넌트 환경을 분리하여 리소스를 생산,개발,QA 환경 등으로 사용
- 리소스 이름은 네임스페이스 내에서만 고유 명칭 사용



현재 클러스터의 기본 네임스페이스 확인

```
kubectl get ns
```



각 네임스페이스 상세 내용 확인

- kubectl get을 옵션없이 사용하면 default 네임스페이스에 질의
- 다른 사용자와 분리된 환경으로 타인의 접근을 제한
- 네임스페이스 별로 리소스 접근 허용과 리소스 양도 제어 가능
- --namespace나 -n을 사용하여 네임스페이스 별로 확인이 가능

```
kubectl get po --namespace kube-system
```



yaml 파일로 네임스페이스 만들기

- test_ns.yaml 파일을 생성하고 create 를 사용하여 생성

```
apiVersion: v1
kind: Namespace
metadata:
	#네임스페이스 이름
	name:teset-ns
```



```
kubectl create -f test_ns.yaml
kubectl get ns
```



kubectl 명령어로 yaml 없이 바로 네임스페이스 생성 가능

```
kubectl create namespace "test-namespace"
```



전체 네임스페이스를 대상으로 kubectl을 실행하는 방법

```
kubectl get pod --all-namespaces
```



## Services

포드의 문제점

- 포드는 일시적으로 생성한 컨테이너의 집합
- 때문에 포드가 지속적으로 생겨났을 때 서비스를 하기에 적합하지 않음
- IP주소의 지속적인 변동, 로드밸런싱을 관리해 줄 또 다른 개체가 필요



요구사항

- 외부 클라이언트가 몇 개이든지 프론트엔드 포드로 연결
- 프론트엔드는 다시 백엔드 데이터베이스로 연결
- 포드의 IP가 변경될 때마다 재설정 하지 않도록 해야함



생성방법

- kubectl의 expose가 가장 쉬움
- YAML을 통해 버전관리 가능

```
http-go-svc.yaml

apiVersion: v1
kind: Service
metadata:
	name: http-go-svc
spec:
	ports:
	- port: 80
	  targetPort: 8080
	selector:
	  app: http-go
```



```
kubectl create -f http-go-svc.yaml

kubectl create -f http-go-rs.yaml

kubectl get svc
```



서비스의 기능 확인

```
kubectl exec <포드 이름> --curl

kubectl exec http-go-rs-4152m -- curl 10.12.0.237:80 -s
```



포드 간의 통신을 위한 ClusterIP

- 다수의 포드를 하나의 서비스로 묶어서 관리









