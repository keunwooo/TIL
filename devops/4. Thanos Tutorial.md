```
이 튜토리얼에서는...에 대해 실행 중인 Prometheus 서버의 일반적인 상태를 모방합니다. 1년! 이를 통해 개체 스토리지의 모든 이전 데이터를 원활하게 백업하고 Prometeus를 연속 백업 모드로 구성하여 Prometheus에 대한 무제한 보존을 비용 효율적으로 실현할 수 있습니다.

마지막으로 쿼리 및 자동 유지 관리(예: 압축, 보존 및 다운샘플링)에 대한 모든 설정을 살펴보겠습니다.

이 모든 것을 보여주기 위해, 이전 과정의 단일 클러스터 설정부터 시작하겠습니다. 프로메테우스의 초기 설정을 시작하죠, 준비됐죠?
```



```
사실, 프로메테우스를 시작하기 전에, 인공적인 데이터를 생성해 봅시다. 타노스에 대해 빨리 알고 싶으실 겁니다. 그래서 이 튜토리얼을 Prometheus가 메트릭스를 수집하는 달까지 몇 개월을 기다리지 않아도 되겠죠? (:

우리는 우리의 편리한 타노스벤치 프로젝트를 이용할 것입니다! 1년 전부터 지금까지(-6시간)에 걸쳐 있는 단 5개의 시리즈(게이지)로 Prometheus 데이터(TSDB 블록의 형태)를 생성해 보겠습니다!
```

```
mkdir -p /root/prom-eu1 && docker run -i quay.io/thanos/thanosbench:v0.2.0-rc.1 block plan -p continuous-365d-tiny --labels 'cluster="eu1"' --max-time=6h | docker run -v /root/prom-eu1:/prom-eu1 -i quay.io/thanos/thanosbench:v0.2.0-rc.1 block gen --output.dir prom-eu1
```



---



```
여기서는 사전 생성된 데이터로 실행할 Prometheus 인스턴스에 대한 구성 파일을 준비합니다. 이 튜토리얼에서 사용할 구성 요소도 스크래치됩니다.
```

```
global :
   scrape_interval :  5 s
   external_labels : 
    cluster : eu1
     replica :  0 
    tenant : team-eu # 필요하지 않지만 언젠가 다중 테넌트 시스템으로 확장하려는 경우 좋은 방법입니다.

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['127.0.0.1:9090']
  - job_name: 'sidecar'
    static_configs:
      - targets: ['127.0.0.1:19090']
  - job_name: 'minio'
    metrics_path: /minio/prometheus/metrics
    static_configs:
      - targets: ['127.0.0.1:9000']
  - job_name: 'querier'
    static_configs:
      - targets: ['127.0.0.1:9091']
  - job_name: 'store_gateway'
    static_configs:
      - targets: ['127.0.0.1:19092']
```

```
이제 Prometeus 인스턴스를 나타내는 컨테이너를 시작하겠습니다.

생성된 데이터를 Prometeus 데이터 디렉토리에 저장할 수 있는 참고 -v/root/prom-eu1:/prometeus \ 및 --storage.tsdb.path=/prometeus입니다.

이제 프로메테우스를 투입합시다.
로컬 Prometheus compacts storage.tsdb.max-block-duration 및 minflags를 사용하지 않도록 설정했습니다. 현재 기본 개체 저장소 백업 시나리오에서 버킷과 로컬 압축 간의 충돌을 피하는 것이 중요합니다. 여기서 더 읽어보세요.

Prometeus 보존도 확장했습니다. --storage.tsdb.dv.time=1000d. 그 이유는 Prometheus가 기본적으로 2주보다 오래된 모든 데이터를 제거하기 때문입니다. 1년이라는 시간이 있습니다(:
```

```
docker run -d --net=host --rm \
    -v /root/editor/prometheus0_eu1.yml:/etc/prometheus/prometheus.yml \
    -v /root/prom-eu1:/prometheus \
    -u root \
    --name prometheus-0-eu1 \
    quay.io/prometheus/prometheus:v2.20.0 \
    --config.file=/etc/prometheus/prometheus.yml \
    --storage.tsdb.retention.time=1000d \
    --storage.tsdb.path=/prometheus \
    --storage.tsdb.max-block-duration=2h \
    --storage.tsdb.min-block-duration=2h \
    --web.listen-address=:9090 \
    --web.external-url=https://2886795283-9090-elsy05.environments.katacoda.com \
    --web.enable-lifecycle \
    --web.enable-admin-api
```

```
이전 과정과 마찬가지로 사이드카를 사용하여 글로벌 보기 쿼리를 설정합니다.
```

```
docker run -d --net=host --rm \
    --name prometheus-0-eu1-sidecar \
    -u root \
    quay.io/thanos/thanos:v0.20.0 \
    sidecar \
    --http-address 0.0.0.0:19090 \
    --grpc-address 0.0.0.0:19190 \
    --prometheus.url http://127.0.0.1:9090
```

```
docker run -d --net=host --rm \
    --name querier \
    quay.io/thanos/thanos:v0.20.0 \
    query \
    --http-address 0.0.0.0:9091 \
    --query.replica-label replica \
    --store 127.0.0.1:19190
```



---

# Step 2 - Object Storage Continuous Backup

```
Prometheus 내에서 1년간의 데이터를 유지하는 것은 가능하지만 쉽지 않습니다. 이 데이터의 크기를 조정, 백업 또는 장기간 유지하기가 어렵습니다. 게다가 Prometeus는 어떠한 복제도 하지 않기 때문에 Prometeus를 사용할 수 없는 경우 쿼리 사용 불가능이 발생합니다.

여기가 타노스가 놀러 오는 곳이야. 한 번의 구성 변경으로 Thanos Sidecar가 Prometheus에 의해 디스크에 정기적으로 유지되는 메트릭 블록을 지속적으로 업로드할 수 있습니다.
```

```
참고: 데이터를 스크래핑할 때 메시지를 표시하고 처음에는 메모리 및 WAL의 모든 샘플을 집계합니다(디스크 쓰기-헤드 로그). 2-3번 히트한 후에야 2h TSDB 블록 형태로 데이터를 디스크로 "압축"합니다. 그렇기 때문에 우리는 여전히 Prometheus에 최신 데이터를 쿼리해야 하지만, 전반적으로 Prometheus 보존을 최소한으로 유지할 수 있습니다. 이 경우 네트워크 파티션의 잠재적인 이벤트를 위한 안전한 버퍼를 가지려면 Prometheus 보존 기간을 6시간 이상 유지하는 것이 좋습니다.
```

## Starting Object Storage: Minio

```
mkdir /root/minio && \
docker run -d --rm --name minio \
     -v /root/minio:/data \
     -p 9000:9000 -e "MINIO_ACCESS_KEY=minio" -e "MINIO_SECRET_KEY=melovethanos" \
     minio/minio:RELEASE.2019-01-31T00-31-19Z \
     server /data
```

```
mkdir /root/minio/thanos
```



## Sidear block backup

```
개체 저장소를 사용하는 모든 Thanos 구성 요소는 동일한 "작은" 버킷 구성 형식을 가진 동일한 objstore.config 플래그를 사용합니다.

구성을 bucket_storage 파일에 전파하려면 구성에 복사를 클릭합니다.
```

bucket_storage.yaml

```
type: S3
config:
  bucket: "thanos"
  endpoint: "127.0.0.1:9000"
  insecure: true
  signature_version2: true
  access_key: "minio"
  secret_key: "melovethanos"
```

Let's restart sidecar with updated configuration in backup mode.

```
docker stop prometheus-0-eu1-sidecar
```

```
docker run -d --net=host --rm \
    -v /root/editor/bucket_storage.yaml:/etc/thanos/minio-bucket.yaml \
    -v /root/prom-eu1:/prometheus \
    --name prometheus-0-eu1-sidecar \
    -u root \
    quay.io/thanos/thanos:v0.20.0 \
    sidecar \
    --tsdb.path /prometheus Deploying store for "EU1" Prometheus data
    --objstore.config-file /etc/thanos/minio-bucket.yaml \
    --shipper.upload-compacted \
    --http-address 0.0.0.0:19090 \
    --grpc-address 0.0.0.0:19190 \
    --prometheus.url http://127.0.0.1:9090
```

```
Tanos 사이드카는 Prometeus가 디스크에 허용하는 모든 블록을 백업할 수 있게 한다. 이를 달성하기 위해서는 다음을 확인해야 합니다.

Sidecar는 Prometeus 데이터 디렉토리에 직접 액세스할 수 있습니다(우리의 경우 호스트의 /root/prom-eu1dir)(--tsdb.path 플래그).

버킷 구성이 --objstore.config-file로 지정되었습니다.

사이드카가 시작될 때 이미 압축된 블록을 업로드하려면 --fileng.filenged를 설정해야 합니다. Thanos 시스템에 도입된 새로운 Prometeus에서 이전에는 볼 수 없었던 블록을 업로드하려는 경우에만 이 옵션을 사용하십시오.
```



#### Thanos Store Gateway

# Step 3 - Fetching metrics from Bucket

```
게이트웨이 저장:
이 구성 요소는 개체 저장소 버킷의 기록 데이터 위에 API를 구현합니다. 주로 API 게이트웨이 역할을 하므로 상당한 양의 로컬 디스크 공간이 필요하지 않습니다.

로컬 디스크의 모든 원격 블록에 대한 적은 양의 정보를 유지하고 버킷과 동기화 상태를 유지합니다. 이 데이터는 일반적으로 시작 시간을 늘려서 재시작할 때 삭제해도 안전합니다.
```

### Deploying store for "EU1" Prometheus data

```
docker run -d --net=host --rm \
    -v /root/editor/bucket_storage.yaml:/etc/thanos/minio-bucket.yaml \
    --name store-gateway \
    quay.io/thanos/thanos:v0.20.0 \
    store \
    --objstore.config-file /etc/thanos/minio-bucket.yaml \
    --http-address 0.0.0.0:19091 \
    --grpc-address 0.0.0.0:19191
```

```
Tanos 저장 데이터를 쿼리하는 방법?
이 단계에서는 타노스 버킷에서 과거 데이터에 액세스할 수 있는 타노스 저장 데이터를 쿼리하고 이 설정을 조금 더 수행할 수 있는 방법을 알아보겠습니다.

현재 쿼리러는 스토어에 대해 아직 알지 못합니다. 쿼리어에 Store Gateway gRPC address --store 127.0.0.1:19191을 추가하여 변경합니다.
```

```
docker stop querier && \
docker run -d --net=host --rm \
   --name querier \
   quay.io/thanos/thanos:v0.20.0 \
   query \
   --http-address 0.0.0.0:9091 \
   --query.replica-label replica \
   --store 127.0.0.1:19190 \
   --store 127.0.0.1:19191
```

```
Prometheus 인스턴스와 Thanos Store를 동시에 쿼리할 수 있는 구성 요소인 Thanos Query가 추가되어 아카이브된 블록과 실시간 메트릭스에 투명하게 액세스할 수 있습니다. 쿼리 내부에 사용되는 바닐라 PromQL Prometheus 엔진은 데이터를 가져오는 데 필요한 시간 시리즈와 시간 범위를 추론한다.

또한, 스토어API는 외부 레이블과 데이터가 있는 시간 범위를 전파하기 때문에 우리는 이것에 대한 기본적인 필터링을 할 수 있다. 그러나 쿼리에 이러한 항목 중 하나를 지정하지 않으면("업" 시리즈만 해당) 쿼리러가 모든 스토어를 동시에 묻습니다.API 서버.

Prometheus+sidcar 결과와 스토어 게이트웨이 사이의 잠재적 데이터 복제는 투명하게 처리되고 결과에서는 보이지 않게 됩니다.
```

```
어떤 스토어를 확인하는 중API가 쿼리에 포함됨

여기서 또 다른 흥미로운 질문은 버킷에서만 데이터를 쿼리할 수 있는지 확인하는 방법입니다.

New UI를 방문하여 1년 그래프 시간 범위와 함께 Continuous_app_metric0 메트릭을 다시 삽입하고 Enable Store Filtering을 클릭하여 이를 확인할 수 있습니다.

이를 통해 상점을 필터링할 수 있으며 데이터를 정확히 쿼리하는 위치에서 디버깅하는 데 도움이 됩니다.

127.0.0.1:19191만 선택하기로 했으니 게이트웨이를 저장하십시오. 이 쿼리는 해당 저장소에서만 데이터를 검색하므로 해당 저장소가 제대로 작동하는지 확인합니다.
```