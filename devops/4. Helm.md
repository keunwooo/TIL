# Helm

출처

https://helm.sh/ko/docs/intro/using_helm/



- *차트*는 헬름 패키지이다. 이 패키지에는 쿠버네티스 클러스터 내에서 애플리게이션, 도구, 서비스를 구동하는데 필요한 모들 리소스 정의가 포함되어 있다. 쿠버네티스에서의 Homebrew 포뮬러, Apt dpkg, YUM RPM 파일과 같은 것으로 생각할 수 있다.

- *저장소*는 차트를 모아두고 공유하는 장소이다. 이것은 마치 Perl의 [CPAN 아카이브](https://www.cpan.org/)나 [페도라 패키지 데이터베이스](https://admin.fedoraproject.org/pkgdb/)와 같은데, 쿠버네티스 패키지용이라고 보면 된다.

- *릴리스*는 쿠버네티스 클러스터에서 구동되는 차트의 인스턴스이다. 일반적으로 하나의 차트는 동일한 클러스터내에 여러 번 설치될 수 있다. 설치될 때마다, 새로운 *release* 가 생성된다.



---

### helm search

```
helm search hub Name
여러 저장소들에 있는 헬름 차트들을 포괄하는 [헬름 허브](https://hub.helm.sh/)를 검색
```



```
helm search repo Name #여러 저장소들에 있는 헬름 차트들을 포괄하는 헬름 허브를 검색
helm repo add#를 사용하여 로컬 헬름 클라이언트에 추가된 저장소들을 검색한다. 
             # 검색은 로컬 데이터 상에서 이루어지며, 퍼블릭 네트워크 접속이 필요하지 않다.

helm search hub
```



### helm install

```
가장 간단하게는 사용자가 지정한 릴리스 이름, 설치하려는 차트 이름의 2개 인수
헬름이 생성해주는 이름을 그대로 사용하려면 릴리스 이름을 넣지 말고 --generate-name을 사용

helm install 
```

릴리스의 상태 추적을 계속하거나, 구성 정보를 재확인하려면, `helm status`를 사용



### 설치 전 차트 커스터마이징

### helm show values

차트에 어떤 옵션이 구성 가능한지 확인

```
helm show values bitnami/grafana
```



**YAML 형식 파일에 있는 이러한 설정들을 오버라이드(override)하여, 설치시 파일과 함께 반영시킬 수 있다.**

```
$ echo '{mariadbUser: user0, mariadbDatabase: user0db}' > config.yaml
$ helm install -f config.yaml stable/mariadb --generate-name
```

위와 같이 하면 `user0`이라는 기본 MariaDB 사용자가 생성될 것이고, 이 사용자에게는 새로 생성된 `user0db` 데이터베이스에 대한 접근권한이 부여되지만, 나머지 모든 기본설정은 해당 차트를 따르게 된다.



**설치 작업에 구성 데이터를 전달하는 방법에는 두가지가 있다.**

```
--values (또는 -f): 오버라이드(override)할 YAML 파일을 지정한다. 여러 번 지정할 수 있지만 가장 오른쪽에 있는 파일이 우선시된다.
--set: 명령줄 상에서 오버라이드(override)를 지정한다.
```

`helm get values <release-name>`로 해당 릴리스에 대한 `--set` 설정값들을 조회할 수 있다. `--set` 설정값들은 `helm upgrade`를 실행할 때 `--reset-values`를 명시하여 제거할 수 있다.



#### `--set`의 형식과 제한점

```
--set name=value
name: value

--set a=b,c=d

--set outer.inner=value
outer:
  inner: value

--set name={a, b, c} (리스트)
name:
  - a
  - b
  - c
  
--set servers[0].port=80 (헬름 2.5.0)
servers:
  - port: 80
  
--set name=value1\,value2 (문자를 이스케이프하기 위해 백슬래시를 사용)
name: "value1,value2"
```



```
persistence:
  enabled: true
  ## Grafana data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  # storageClass: "-"
  ##
  ## If you want to reuse an existing claim, you can pass the name of the PVC using
  ## the existingClaim variable
  # existingClaim: your-claim
  accessMode: ReadWriteOnce
  size: 10Gi

```



한줄 소감 및 의문점

---

Chart가 템플릿 기반이니까 기본 스펙 설정은 템플릿에서 동적인 설정값 부분을 변수값으로 설정하고 value.yaml 파일에 변수값을 추가하고 해당 yaml 파일을 이용하여 한번에 변수 값을 변경한다?



 Chart 생성을 하기 위해서 생각하는 공부 순서가...

1.  헬름 사용법 (대충 Ok)
2. 헬름 차트 생성법
3. 쿠버네티스 Deploy의 각 설정값들 및 세팅값 공부 
4. 즉, 기본적인 쿠버네티스 근본 공부가 더 필요할듯
5. Cluster role 이랑 pvc pv 등 실제 안써본 개념들 언제 필요할지..
6. Docker로 실행하던 명령문을 쿠버네티스 deploy.yaml 형식으로 변환이 가능해야 함



helm upgrade telegraf -f values.yaml influxdata/telegraf-ds

helm search repo

helm search hub



---

## Helm Chart 

헬름 차트는 다음과 같이 구성됨

```
mychart/
 Chart.yaml
 values.yaml
 charts/
 templates/
 ...
```

`templates/` 디렉토리는 템플릿 파일을 위한 것이다.

헬름이 차트를 평가할 때, `templates/` 디렉토리의 모든 파일을 템플릿 렌더링 엔진으로 전달한다. 그리고 나서 처리 결과를 모아 쿠버네티스로 보낸다.

`values.yaml` 파일도 템플릿에 중요하다. 이 파일은 차트의 *기본값* 을 포함한다. 이 값들은 `helm install` 또는 `helm upgrade` 하는 중에 사용자가 재정의할 수 있다.

`Chart.yaml` 파일은 차트에 대한 설명을 포함한다. 템플릿 안에서 접근할 수 있다. `charts/` 디렉토리는 다른 차트(*하위차트* 라고 함)를 포함 *할 수도* 있다. 본 가이드의 뒷부분에서 템플릿 렌더링과 관련하여 이러한 기능이 어떻게 작동하는지 알아볼 것이다.



헬름 차트 생성

```
helm create mychart
```

### `mychart/templates/` 훑어보기

`mychart/templates/` 를 보면 이미 몇 개의 파일이 있는 것을 알 수 있다.

- `NOTES.txt` : 차트의 "도움말". 이것은 `helm install` 을 실행할 때 사용자에게 표시될 것이다.
- `deployment.yaml` : 쿠버네티스 [디플로이먼트](https://kubernetes.io/ko/docs/concepts/workloads/controllers/deployment/)를 생성하기 위한 기본 매니페스트
- `service.yaml` : 디플로이먼트의 [서비스 엔드포인트](https://kubernetes.io/ko/docs/concepts/services-networking/service/)를 생성하기 위한 기본 매니페스트
- `_helpers.tpl` : 차트 전체에서 다시 사용할 수 있는 템플릿 헬퍼를 지정하는 공간



( 튜토리얼 )

```
rm -rf mychart/templates/*
```

```
vi mychart/templates/configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: "Hello World"
```

이 파일은 `mychart/template/` 디렉토리에 있기 때문에 템플릿 엔진으로 전달된다.



이 간단한 템플릿으로 우리는 이제 설치 가능한 차트를 가지고 있다. 이렇게 설치하면 된다:

```
helm install full-coral ./mychart
```

헬름을 사용하면 릴리스를 검색해 실제 전송된 템플릿을 볼 수 있다.

```
helm get manifest full-coral
```



`helt get manifest` 명령은 릴리스 이름(`full-coral`)을 가지고 서버에 업로드된 쿠버네티스 리소스를 모두 출력한다. 각 파일은 `---`로 시작하여 YAML 문서의 시작을 표시한 다음 자동으로 생성된 주석이 나타나 이 YAML 문서를 생성한 템플릿 파일을 알려준다.



### 단순한 템플릿 호출 추가하기

`name:` 을 리소스 안에 하드 코딩하는 것은 보통 좋지 못한 관행으로 간주된다. 이름은 릴리스에 고유해야 한다. 그래서 릴리스 이름을 삽입하여 이름 필드를 생성하기를 원할 수 있다.

configmap.yaml 수정

```
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: "Hello World"
```

템플릿 지시문은 `{{` 와 `}}` 으로 감싼다.

템플릿 지시문 `{{ .Release.Name }}` 은 템플릿에 릴리스 이름을 주입한다. 템플릿으로 전달되는 값은 *네임스페이스 객체* 로 생각할 수 있으며, 여기서 점(`.`)이 각 네임스페이스 요소를 구분한다.

`Release` 앞의 점은 해당 스코프(조금 있으면 스코프에 대해 설명하겠다)의 최상위 네임스페이스부터 시작한다는 것을 나타낸다. 그래서 우리는 `.Release.Name`을 "최상위 네임스페이스에서부터 시작하여 `Release` 객체를 찾은 다음 `Name`이라는 객체를 찾아보라"로 읽을 수 있다.



```
helm install clunky-serval ./mychart
```



다음 단계로 넘어가기 전에 템플릿을 더 빨리 만들 수 있는 한 가지 요령을 보자: 실제로 아무것도 설치하지 않지만 템플릿 렌더링을 테스트하고 싶다면 `helm install --debug --dry-run goodly-guppy ./mychart` 를 사용할 수 있다. 이렇게 하면 템플릿이 렌더링된다. 그러나 차트를 설치하는 대신 렌더링 된 템플릿을 반환하여 이러한 출력을 볼 수 있다:



## 빌트인 객체



객체는 템플릿 엔진에서 템플릿으로 전달된다. 그리고 사용자의 코드는 객체를 전달할 수 있다.

이후에 보게 될 `tuple` 함수와 같이 템플릿 내에서 새로운 객체를 만드는 몇 가지 방법이 있다.



`Release` 는 내 템플릿에 접근할 수 있는 최상위 객체 중 하나이다.

- ```
  Release
  ```

  : 이 객체는 릴리스 자체를 서술한다. 여러 객체를 가지고 있다. 그 내부:

  - `Release.Name`: 릴리스 이름
  - `Release.Namespace`: 릴리스될 네임스페이스 (manifest에서 오버라이드하지 않은 경우)
  - `Release.IsUpgrade`: 현재 작업이 업그레이드 또는 롤백인 경우 `true` 로 설정된다.
  - `Release.IsInstall`: 현재 작업이 설치일 경우 `true` 로 설정.
  - `Release.Revision`: 이 릴리스의 리비전 번호. 설치시에는 이 값이 1이며 업그레이드나 롤백을 수행할 때마다 증가한다.
  - `Release.Service`: 현재 템플릿을 렌더링하는 서비스. Helm 에서는 항상 `Helm` 이다.



- `Values`: `values.yaml` 파일 및 사용자 제공 파일에서 템플릿으로 전달된 값. 기본적으로 `Values` 는 비어 있다.

- `Chart`: `Chart.yaml` 파일의 내용. `Chart.yaml` 안의 모든 데이터는 여기서 접근 가능하다. 예를 들어 `{{ .Chart.Name }}-{{ .Chart.Version }}` 은 `mychart-0.1.0` 를 출력한다.

  사용가능한 필드는 [차트 가이드](https://helm.sh/ko/docs/topics/charts/#the-chartyaml-file) 에 나열되어 있다.

- `Files`: 차트 내의 모든 특수하지 않은(non-special) 파일에 대한 접근을 제공한다. 템플릿에 접근하는 데에는 사용할 수 없지만, 차트 내의 다른 파일에 접근하는 데에는 사용할 수 있다. 자세한 내용은 *Accessing Files* 섹션을 참고하자.
  - `Files.Get` 은 이름으로 파일을 가지고 오는 함수이다. (`.Files.Get config.ini`)
  - `Files.GetBytes` 는 파일의 내용을 문자열이 아닌 바이트 배열로 가져오는 함수이다. 이미지 같은 것을 다룰 때 유용하다.
  - `Files.Glob` 는 이름이 주어진 shell glob 패턴과 매치되는 파일 목록을 반환하는 함수이다.
  - `Files.Lines` 는 파일을 한 줄씩 읽는 함수이다. 이것은 파일 내의 각 행을 순회(iterate)하는데 유용하다.
  - `Files.AsSecrets` 은 파일 본문을 Base64로 인코딩된 문자열로 반환하는 함수이다.
  - `Files.AsConfig` 는 파일 본문을 YAML 맵으로 반환하는 함수이다.



- `Capabilities`: 쿠버네티스 클러스터가 지원하는 기능에 대한 정보를 제공한다.
  - `Capabilities.APIVersions` 는 버전의 집합이다.
  - `Capabilities.APIVersions.Has $version` 은 버전(예: `batch/v1`) 이나 리소스(예: `apps/v1/Deployment`) 를 클러스터에서 사용할 수 있는지 여부를 나타낸다.
  - `Capabilities.KubeVersion` 과 `Capabilities.KubeVersion.Version` 는 쿠버네티스 버전이다.
  - `Capabilities.KubeVersion.Major` 는 쿠버네티스 메이저 버전이다.
  - `Capabilities.KubeVersion.Minor` 는 쿠버네티스 마이너 버전이다.