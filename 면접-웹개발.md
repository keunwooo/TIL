# 웹 개발

\1. CVS나 SVN에 대해서 아는대로 설명해 보시오.

 

\2. 64bit CPU와 32bit CPU의 OS적 관점에서의 차이를 설명해 보시오.

 

\3. 프로세스와 쓰레드의 차이점에 대해서 설명해 보시오.( 메모리 구조 포함 )

 

\4. ‘데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.

 

\5. 변수 명명법이 중요한 이유에 대해서 설명하고 예를 들어 보시오.

 

\6. 자바의 JVM의 역할에 대해서 설명해 보시오.

 

\7. 자바의 특징에 대해서 말해 보시오.

 

\8. Linux에서 톰캣 환경설정을 잡는 것에 대해 설명해 보시오.

 

\9. WAS와 웹서버의 차이점은?

 

\10. Jquery와 Ajax에 대해 아는가?

 

\11. 비동기와 동기 방식의 차이점에 대해서 말해보시오.(네트워크 동기,비동기 아님)

 

\12. 개발시에 중요하다 생각하는 요소를 3가지 기술해 보시오.

 

\13. 스프링의 MVC에 대해서 설명하시오.

 

\14. AOP란 무엇이고 왜 사용하는지

 

\15. ‘에자일’ 방법론에 대해서 아는가?

 

\16. 스프링 환경설정 혼자 잡을 수 있는가? 대강 어떻게 해야하는지 설명해 보시오.

 

\17. 웹서버 내부 구동 방식에 대해 설명할 수 있는가?

 

\18. 스프링 DI란?

 

\19. UML 그려본 적 있는가?

 

\20. Node js나 Angular JS를 사용해 본 적이 있는가?

 

\21. 캐시와 세션의 공통점과 차이점에 대해 말해보시오.

 

\22. 디자인 패턴 아는 것들만 간략히 설명해 보시오.

 

\23. DataBase에서 index관련 질문이었는대 잘 모르겠어서..기억이..

 

\24. 크롬이나 파이어폭스에서 개발도구를 사용해 디버깅을 해보았는가?

 

\25. JDBC는 무엇인가?

 

\26. 스프링을 사용하지 않고 MVC를 JSP에서 만들어 보았는가?

 

\27. DB 옵티마이저에 대해 아는가?



**1) 자바의 특징에 대해 말해보시오.**

1) OOP(객체 지향 언어) 

: 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법

2) "가비지 컬렉션"에 의한 메모리 자동 관리

3) "멀티 쓰레드"를 지원한다.

4) JVM 위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며, 보안성이 좋다.

5) 다양한 Open 라이브러리들이 존재한다.





**2) 자바를 만든 사람에 대해 아시나요?**

: "제임스 고슬링"





**3) 변수란?**

: "하나의 값을 저장할 수 있는 메모리 공간"





**4) 객체와 클래스의 차이점에 대해 설명해 보시오.**

\- 클래스(Class) : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것으로 "아직 메모리가 할당되지 않은 상태"

vs

\- 객체(Object) : 이 Class라는 설계도를 기반으로 실제 메모리가 잡힌 것을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해

  나가는 방식을 OOP(객체지향 프로그래밍)이라고 한다.





**5) 객체 지향 PG이란? 또 그 특징은?**

: 현실세계의 객체를 필드와 메서드로 정의한 Class를 기반으로 실제 메모리가 잡혀 만들어진 부품과 같은 객체들을 조합해

 전체 프로그램을 완성해 나가는 개발 기법으로

특징)

\- 캡슐화, 은닉화 : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 있는 getter/setter 메서드를 통해 접근하도록 하는 방식

\- 상속 : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식

\- 다형성 : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질

등을 들 수 있다.





**6) 다형성이란?**

: 서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질





**7) 자바의 메모리 영역(간단하게 설명)**

\1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.

  , 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.

\2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리

\3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.





**8) 추상메서드? 추상 클래스?**

\- 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드

\- 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기

​    때문에 객체화 할 수 없다.





**9) 인터페이스(Interface)란? 또 왜 사용하나?**

: 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로

 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.



왜 인터페이스를 사용하는가? 

: 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의

 메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의

 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.

 또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 

 상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.





**10) 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?**

\- 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에

  서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.

\- 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의

 자원(메모리)는 프로세스 내에서 공유하게 된다.





**11) 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.**



\- Collection 인터페이스 

\- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.

ex) - ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를

옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.

  \- LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만

연결하면 되기 때문에 삽입, 삭제에 유리하다.

  \- Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리

Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

\- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우

 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.

ex) - HashSet

  \- TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

  



\- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.

ex) - HashMap

   \- TreeMap

   \- Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.

   \- Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

**12) 쿠키(Cookie)와 세션(Session)의 공통점과 차이점은?**

\- 공통점 : 둘 다 사용자의 데이터를 저장한다.

\- 차이점

\- 쿠키: 쿠키는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.

\- 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.



**13) Request 전송 방식에는 어떤 것들이 있는지 아시나요?**

\- Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.

\- POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.

\- DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.

\- PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.





**14) RESTFUL이란?**

: 해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식





**15) Spring에서 DI란 무엇인지 아시나요?**

: DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.

 DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 

 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 

 Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.





**16) Spring의 AOP란?**

: AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하

 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로

 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에

 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.





**17) Filter와 Interceptor 방식의 차이?**

: 





**18) 디자인 패턴 아는 것?**

1) 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우

 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.

2) 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는

  생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.

3) 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로

  사용됩니다.





**19) MVC 패턴이란?**

\- Model : data 처리와 접근을 담당

\- View : Client에 보여지는 화면을 담당

\- Controller : Model과 View를 제어

하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.





**20) 프로젝트 개발 순서??**

대강...

1) 요구사항 분석 

기획 및 스토리 보드 작성

2) WBS(Work Breakdown Structure) 작성 : 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도

3) 논리 ERD 작성

4) 물리 ERD 작성

5) 개발

6) Testing

7) 유지보수





**21) 오버로딩과 오버라이딩의 차이?**

\- 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식

\- 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식



**22) Servlet vs JSP**

\- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것

\- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



**23) Wrapper Class의 사용이유를 아나요?**

: 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로

 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며

 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.





**24) DataBase에서 Index란?**

: Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.





**25) private, protected, public, default 제어자에 대해 설명해 보시오**

\- private : 같은 class 내부에서"만" 접근이 가능하다.

\- public : 어디서든 자유롭게 접근이 가능하다.

\- protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.

\- default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.





**26) SI가 무엇을 하는 건지 알고 오셨나요?**

: System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.





**27) SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?**

: Testing 부분입니다. 





**28) 자바의 제네릭이란??**

: 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식



**17. Spring Framework(스프링 프레임워크)**

자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)

자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크

자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구

자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

**스프링 특징 간단히**

\- 크기와 부하의 측면에서 경량.

\- **제어 역행(IoC)**이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모

\- **관점지향 프로그래밍****(AOP)**을 위한 풍부한 지원

\- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음

\- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음

**스프링 특징 자세히**

**a. 경량 컨테이너로서 자바 객체를 직접 관리.**

  각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.

**b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.**

  일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 

  존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.

**c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.**

  컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

**d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원**

  각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

**e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원**

  따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

**f. 스프링은 영속성과 관련된 다양한 서비스를 지원**

  iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

**g. 스프링은 확장성이 높음.**

  스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 

  이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.





**18. Thread**

**Thread(쓰레드)** - 프로세스내에서 동시에 실행되는 **독립적인 실행 단위**를 말함, 장점으로는 자원을 많이 사용하지 않고 구현이 쉬우며 범용성이 높다

**Process(프로세스)** - **운영체제에서 실행중인 하나의 프로그램**(하나 이상의 쓰레드를 포함한다.)

**Thread 장점**

\- 빠른 프로세스 생성

\- 적은 메모리 사용

\- 쉬운 정보 공유

**Thread 단점**

\- **교착상태**에 빠질 수 있다.

\* 교착상태 - 다중프로그래밍 체제에서 하나 또는 그 이상의 프로세스가 수행 할 수 없는 어떤 특정시간을 기다리고 있는 상태.

**Thread와 Process 차이**

여러 분야에서 '과정' 또는 '처리'라는 뜻으로 사용되는 용어로 컴퓨터 분야에서는 '실행중인 프로그램'이라는 뜻으로 쓰인다. 

이 프로세스 내에서 실행되는 각각의 일을 스레드라고 한다. 프로세스 내에서 실행되는 세부 작업 단위로 여러 개의 스레드가 하나의 프로세스를 이루게 되는 것이다.



**1. JAVA**

JAVA는 네트워크상에서 쓸 수 있도록 미국의 선 마이크로 시스템즈가 개발한 **객체 지향 프로그래밍 언어**

**JAVA의 특징**

a. 자바가상머신(JVM)만 설치하면 컴퓨터의 **운영체제에 상관없이 작동**한다.(즉, **운영체제에 독립적**)

b. 기본 자료형을 제외한 모든 요소들이 객체로 표현

c. 객체 지향 개념의 특징인 **캡슐화, 상속, 다형성**이 잘 적용된 언어

d. Garbage Collector를 통한 **자동적인 메모리 관리**

e. **멀티쓰레드**(Multi-thread)를 지원





**2. OOP(객체지향 프로그래밍)**

OOP란 Object-Oriented Programming의 약어로써 객체지향 프로그래밍을 의미

**데이터를 객체로 취급**하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는

다르게 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말한다.

**OOP 특징**

a. 객체지향 프로그래밍은 **코드의 재사용성**이 높다.

b. 코드의 변경이 용이

c. 직관적인 코드분석

d. 개발속도 향상

e. 상속을 통한 장점 극대화





**3. Object**

Object(객체)는 OOP에서 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념

예)기차역에서 승차권을 발매하는 경우, 실체인 '손님'과 동작인 '승차권 주문'은 하나의 객체이며, 실체인 '역무원'과

동작인 '승차권 발매'도 하나의 객체이다.

같은 성질, 같은 구조와 형태를 가지는 객체는 등급으로 정의하고 등급에 속하는 객체는 그 등급의 인스턴스라고 한다.





**4. Overloading vs Overriding** ( 한번공부할때 확실히 차이를 알아둘 것, 평소에 알고 있어도 헷갈림)

**Overloading(오버로딩)**

\- **같은 이름의 메소드를 여러개 정의**하는 것

\- **매개변수의 타입이 다르거나 개수가 달라야 한다.**

\* return type과 접근 제어자는 영향을 주지 않음.



**Overriding(오버라이딩)**

\- 상속에서 나온 개념

\- **상위 클래스(부모 클래스)의 메소드를 하위 클래스(자식 클래스)에서 재정의**





**5. Servlet, JSP**

**Servlet** - Container가 이해할 수 있게 구성된 순수 자바 코드로만 이루어진 것(**Html in JAVA**)

**JSP(Java Server Page)** - html기반에 JAVA코드를 블록화하여 삽입한 것(**JAVA in Html**)





**6. JDBC**

Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍을 의미





**7. Get과 Post 방식**

**Get 방식**

\- 클라이언트에서 서버로 데이터를 전달할 때, **주소 뒤에 "이름"과 "값"이 결합된 스트링 형태**로 전달

\- 주소창에 쿼리 스트링이 그대로 보여지기 때문에 **보안성이 떨어진다**.

\- **길이에 제한**이 있다.(=전송 데이터의 한계가 있다.)

\- **Post방식보다 상대적으로 전송 속도가 빠르다**.



**Post 방식**

\- 일정 크기 이상의 데이터를 보내야 할 때 사용한다.

\- 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.

\- 주소창에 전송하는 데이터의 정보가 노출되지 않아 **Get방식에 비해 보안성이 높다**.

\- **속도가 Get방식보다 느리다**.

\- 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 **객체들의 값도 전송가능**.



**Get과 Post 차이점**

\- Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용

\- Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.

\- Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.

\- Post방식은 전달되는 데이터가 보이지 않는다.

\- Get방식은 전달되는 데이터가 255개의 문자를 초과하면 문제가 발생할 수 있다.

\- 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.





**8. Session과 Cookie**

**Session과 Cookie 사용 이유**

\- 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다

 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 



 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.



**Session**

\- 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.

\- Session에 관련된 데이터는 **Server에 저장**된다.

\- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.

\- **Cookie에 비해 보안성이 좋다**.



**Cookie**

\- 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법

\- 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.

\- Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써,

 Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.



\- Cookie는 **Client PC에 저장**되는 정보기 때문에, **다른 사용자에 의해서 임의로 변경이 가능**하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)



**Q. 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?**



A. 모든 정보를 **Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리**가 감





**9. MVC 패턴**

**MVC란?**

\- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,

\- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

**MVC 구성요소**

**Model** - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 **논리적 데이터 기반 구조를 표****현**. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

**View** - 사용자 인터페이스 내의 구성요소들을 표현(**사용자에게 보여지는 화면**)

**Controller** - Model과 View를 연결하고 있는 클래스를 대표, **Model과 View 내의 클래스들 간 정보 교환**하는데 사용.





**10. Interface, Abstract**

**Interface**

\- **일종의 추상 클래스**

\- 오직 **추상메서드와 상수만을 멤버**로 갖는다.

\- **Implements** 키워드를 사용

\- 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다.

\- Extends는 하나의 클래스만 상속 가능하나 **Interface는 다중 상속이 가능**하다.

**Abstract**

\- **추상메서드를 하나 이상 가진 클래스**

\- **자신의 생성자로 객체 생성 불가능**

\- 하위 클래스를 참조하여 상위 클래스의 객체를 생성

\- 하위 클래스를 제어하기 위해 사용

**
**

**Interface vs Abstract**

**공통점** 

\- new 연산자로 인스턴스 생성 불가능.

\- 프로토타입만 있는 메서드를 갖는다.

\- 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.

**차이점**

\- 사용하는 키워드가 다르다.

\- Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.





**11. Call by Reference, Call by Value**

**Call by Reference** - **매개 변수의 원래 주소에 값을 저장**하는 방식. 클래스 객체를 인수로 전달한 경우

**Call by Value** - 인수로 기본 데이터형을 사용. **주어진 값을 복사하여 처리**하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.





**12. Static의 의미** 

\- 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미

\- 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(**객체와 무관한 키워드**)





**13. Framework**

\- 특정 형태의 소프트웨어 문제를 해결하기 위해 상호 협력하는 클래스프레임과 인터페이스 프레임의 집합

\- 특정한 틀을 만들어놓고 거기에 살을 붙여 놓음으로써 프로그램을 만들어 작업시간을 줄여주는 것이다. 

\- 프레임워크는 특정 개념들의 추상화를 제공하는 여러 클래스나 컴포넌트로 구성된다.

\- 프레임워크는 이렇게 추상적인 개념들이 문제를 해결하기 위해 같이 작업하는 방법을 정의한다.

\- 프레임워크 컴포넌트 들은 재사용이 가능하다.

\- 프레임워크는 좀 더 높은 수준에서 패턴을 조작한다.

\* 프레임워크가 중요한 이유는 객체지향 개발을 하게 되면서 개발자의 취향에 따라 다양한 프로그램이 나오게 되었다.

 프로그램 개발에 투입되는 개발자도 점점 늘어남에 따라 전체 시스템의 통합성, 일관성이 부족하게 되었기 때문이다. 

 그래서 개발자의 자유를 제한하기 위해 프레임워크를 도입했다.

**프레임워크가 가져야할 특징**

a. 개발자들이 따라야할 가이드라인을 가진다.

b. 개발할 수 있는 범위가 정해져 있다.

c. 개발자를 위한 다양한 도구들이 지원된다.

**프레임워크의 장/단점**

장점 - 개발 시간을 줄일 수 있고 오류로부터 자유로울 수 있다.

단점 - 프레임워크에 너무 의존하면 개발 능력이 떨어져서 프레임워크 없이 개발하는 것이 불가능해지는 점이다.

**14. Garbage Collection(가비지 컬렉션)**

시스템에서 **더이상 사용하지 않는 동적 할당된 메로리 블럭을 찾아 자동으로** **다시 사용 가능한 자원으로 회수**하는 것으로 

시스템에서 가비지컬렉션을 수행하는 부분을 **가비지 컬렉터**라 부른다.





**15. Primitive type과 Reference type**

**Primitive type** - 변수에 값 자체를 저장 

정수형 byte, short, int, long

실수형 float, double

문자형 char

논리형 boolean

\* **Primitive type은 Wrapper Class를 통해 객체로 변형**할 수 있다.

예) int→Integer, char→Character(int와 char를 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float→Float)

**Reference type** - 메모리상에 객체가 있는 위치를 저장

종류 - Class, Interface, Array 등



**스레드와 프로세스의 차이는?**

 : (스레드) 프로세스가 할당 받은 자원을 이용하는 실행 단위, 프로세스 하나가 생성되면 하나의 메인스레드 생성됨. 추가하지 않는 한 모든 코드는 메인스레드에서 실행됨.

 (프로세스) 운영체제로부터 자원을 할당 받는 작업의 단위, 컴퓨터에서 실행중인 프로그램



**SI ** **와 SM의 차이는?**

 : (System Integration) 새로운 시스템 구축을 위해 일정기간 프로젝트를 진행

 새로운 IT개발 기술이나 다양한 개발 경험으로 다양한 분야를 접하며 빠르게 성장할 것

(System Management) 그렇게 구축된 시스템을 오픈 이후에 사용하며 개선사항/ 오류사항에 대한 유지보수

 개발된 시스템을 분석, 필요한 기능을 추가하거나 수정하면서 업무지식에 대한 전문가로 성장



> 애플리케이션을 Model, View, Controller 영역으로 구분하여 개발합니다. 영역간의 결합도를 최소화한 디자인 패턴.
> 사용자에게 보여지는 프레젠테이션 영역과 비즈니스 로직, 데이터 구조가 서로 완전히 분리되어 있다

- **Model:** 데이터를 가진 객체, 파라미터로 자주 쓰인다. DB의 테이블과 대응하는 경우가 많다.
- **View:** UI를 담당한다. 클라이언트 측 기술인 Html, Css, Javascript등으로 만들어진 컨테이너이다.
- **Controller:** UI를 통한 사용자의 입력 명령에 응답하고, 및 데이터 흐름 제어를 담당한다



### JSP (Java Server Page) 

> html 내에 자바코드를 블록화하여 삽입한 것(JAVA in Html)웹서버에서 동적으로 웹브라우저를 관리하는 언어

### Servlet 서블릿

> **Container가 이해할 수 있도록 구성된 자바코드로 이루어진 것 (Html in JAVA)**

- 자바 플랫폼에서 웹 앱을 개발할 때 사용하는 핵심기술
- 따라서 컨트롤러와 뷰의 역할분담이 가능해지며 자바API를 모두 쓸 수 있고, 다양한 서버환경에서 실행할 수 있다
- 스레드를 기반으로 한다.
- **Servlet Container** : Servlet을 서버에서 실행하기 위한 서버 프로그램 (서버는 서블릿 자체를 직접 실행 못함)
  JVM을 내장하고 있다.



**DAO**



Data Access Object의 약자로 간단히 Database의 data에 접근을 위한 객체입니다. Database에 접근을 하기위한 로직과 비즈니스 로직을 분리하기 위해서 사용을 합니다

DAO(Data Access Object)는 DB를 사용해 데이터를 조화하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.



**DTO**

DTO(Data Transfer Object)는 VO(Value Object)로 바꿔 말할 수 있는데 계층간 데이터 교환을 위한 자바빈즈를 말합니다.여기서 말하는 계층간의 Controller, View, Business Layer, Persistent Layer를 말하며 각 계층간 데이터 교환을 위한 객체를 DTO 또는 VO라고 부릅니다. 그런데 VO는 DTO와 동일한 개념이지만 read only 속성을 가짐



**Spring MVC 구조의 처리 과정을 설명하라**

\1. DispatcherServlet : 어플리케이션으로 들어오는 모든 Request를 받는 관문이다. Request를 실제로 처리할 Controller 에게 전달하고 그 결과값을 받아서 View에게 전달하여 적절한 응답등 생성할 수 있도록 흐름을 제어한다.

\2. HandlerMapping : Request URL 각각을 어떤 Controller 가 실제로 처리할 것인지 찾아주는 역할을 한다.

\3. Controller : Request를 직접 처리한 후 그 결과를 다시 DispatcherServlet 에게 돌려준다.

\4. ModelAndView : Controller가 처리한 결과와 그 결과를 보여줄 View에 관한 정보를 담고 있는 객체이다.

\5. ViewResolver : View 관련 정보를 갖고 실제 View를 찾아주는 역할을 한다.

\6. View : Controller가 처리한 결과값을 보여줄 View를 생성한다.



**스프링 부트와 스프링의 차이**

스프링 부트는 스프링 프레임워크르 사용하는 프로젝트를 간편하게 셋업할 수 있는 서브 프로젝트이다. 독립 컨테이너에서 동작할 수 있기 때문에 embeded tomcat이 자동으로 실행됩니다. embeded container에서 어플리케이션에서 실행시키기에는 다소 불안전하기 때문에 큰 프로젝트에서는 사용하지 않는 것이 좋다.

**IOC란 무엇인가** 



인스턴스 생성의 제어를 개발자 본인이 아닌 다른 누군가에게 반환해 준다는 개념으로 여기서 말하는 다른 누군가는 Servlet과 같은 bean을 관리해주는 컨테이너이다.

즉 IOC란 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너가 대신 관리해준 다는 것이다.

**Spring에서 DI란 무엇인지 아시나요?**



DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.

DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 

Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.

설정 파일을 통해 객체간의 의존관계를 설정함으로써 외부 Assembler가 객체간의 의존 관계를 정의하게 되며, 객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없어지므로 코드의 관리가 쉬워진다.

**스프링의 MVC에 대해서 설명하시오.**

**
**



\- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,

\- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

MVC 구성요소

Model - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

View - 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)

Controller - Model과 View를 연결하고 있는 클래스를 대표, Model과 View 내의 클래스들 간 정보 교환하는데 사용.

Spring Framework(스프링 프레임워크)

자바(JAVA) 플랫폼을 위한 오픈소스(Open Source) 애플리케이션 프레임워크(Framework)

자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임워크

자바 개발을 위한 프레임워크로 종속 객체를 생성해주고,  조립해주는 도구

 

자바로 된 프레임워크로 자바SE로 된 자바 객체(POJO)를 자바EE에 의존적이지 않게 연결해주는 역할

스프링 특징 간단히

\- 크기와 부하의 측면에서 경량.

\- 제어 역행(IoC)이라는 기술을 통해 애플리케이션의 느슨한 결합을 도모

\- 관점지향 프로그래밍(AOP)을 위한 풍부한 지원

\- 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 컨테이너(Container)라고 할 수 있음

\- 간단한 컴포넌트로 복잡한 애플리케이션을 구성하고 설정할 수 있음



스프링 특징 자세히

 a. 경량 컨테이너로서 자바 객체를 직접 관리.

  각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.

b. 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크.

  일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속을 받을 필요가 없어 기존에 

  존재하는 라이브러리 등을 지원하기에 용이하고 객체가 가볍다.

c. 스프링은 제어의 역행(IoC : Inversion of Control)을 지원.

  컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.

d. 스프링은 의존성 주입(DI : Dependency Injection)을 지원

  각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

e. 스프링은 관점 지향 프로그래밍(AOP : Aspect-Oriented Programming)을 지원

  따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.

f. 스프링은 영속성과 관련된 다양한 서비스를 지원

  iBatis나 Hibernate 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

g. 스프링은 확장성이 높음.

  스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 

  이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.



**Spring의 AOP란?**



AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.



**OOP란 ?**



데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다. 캡슐화, 다형성, 상속 을 이용하여 코드 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것 입니다.

**
**

**자바의 메모리 영역(간단하게 설명)**



\1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.

\2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리

\3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

 

인터페이스(Interface)란? 또 왜 사용하나?

인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로

정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.

 

– 메모리 상수풀 영역 이란

힙영역(프로그래머가 관리하는 메모리 영역)에 생성되어 자바 프로세스 종료까지 계속 유지되는 메모리영역입니다. 기본적으로 JVM에서 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴합니다. 그로 인해 메모리 절약 효가가 있습니다.



**왜 인터페이스를 사용하는가?** 



팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의

메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의



작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.



또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 

상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.



**jdbc란 무엇인가**

**
**

자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.



**직렬화란 무엇인가**



자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동했습니다. 하지만 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없습니다. 따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를 '직렬화' 라고 합니다. 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 합니다.



**serialVersionUID를 선언해야 하는 이유**

자바가상기계 (JVM)은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여합니다. 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당합니다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수도 있습니다. 이런 문제를 해결하기 위해 SerialVerionUID를 사용합니다.

간단명료하게 serialVersionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도입니다.



만약 직렬화할 때 사용한 serialVersionUID의 값과 역직렬화 하기 위해 사용했던 serialVersionUID값이 다르다면 InvalidClassException이 발생할 수 있습니다.



**리플렉션이란 무엇인가요**



리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말합니다. 즉 동적인 언어의 특징이라 말 할 수 있습니다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용하기도 합니다.



**자바의 클래스 멤버 변수 초기화 순서에 대해서 설명하라.**



\1. static 변수 선언부 : 클래스가 로드 될 때 (메모리 모델상 Methd area 에 올라감) 변수가 제일 먼저 초기화 됨



\2. 필드 변수 선언부 : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감) 생성자 block 보다 앞서 초기화 함



\3. 생성자 block : 객체 생성 될 때 (메모리 모델상 Heap area에 올라감)

JVM이 내부적으로 locking (thread safe 영역임)

필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하는 시점은) 생성자 block이 끝난 다음.

필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀



초기화 시점

   \* 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다. 

   \* 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.



초기화 순서

   \* 클래스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 클래스 초기화 블럭 

   \* 인스턴스변수의 초기화순서 : 기본값 -> 명시적초기화 -> 인스턴스 초기화 블럭 -> 생성자



**Servlet vs JSP**



\- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것

\- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



**제너릭**



클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것

형변환을 할 필요없고, 타입 에러가 발생할 확률이 없어진다. 



타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다. 



**컬렉션(collection) 클래스에서 제네릭을 사용하는 이유를 설명하시오.**



컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포함 될 수 있도록 컬렉션을 제한합니다. 

컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와줍니다.



**pojo란 무엇인가**



Plain Old Java Object. 간단히 포조 라는 말 그대로 해석하며 ㄴ오래된 방식의 자바 오브젝트로서 J2EE등의 중량 프레임워크들을 사용하면서 해당 프레임워크에 종석된 무거운 객체를 만들게 된 것에 반발하여 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않는 자바 오브젝트를 지칭하는 말로 사용되었다.



**박싱과 언박싱에 대해서 설명해 보세요.**



원시형 -> Wrapper Class로 변환 박싱

Wrapper Class -> 원시형으로 변환 언박싱

여기에 명시적, 묵시적으로 변하는 것을 설명하면 좋을 것 같음.



**'데드락’ 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오**



데드락이란, 둘 이상의 쓰레드가 lock 을 획득하기 위해 기다리는데, 이 lock 을 잡고 있는 쓰레드도 똑같이 다른 lock 을 기다리며 서로 블록 상태에 놓이는 것을 말한다. 데드락은 다수의 쓰레드가 같은 lock 을, 동시에, 다른 명령에 의해, 획득하려 할 때 발생할 수 있다.

\- 자원 유형에 따라 우선 순위를 선정하여 자원을 선점하게 한다.

\- 공유 불가능한 즉 상호 배제의 조건을 제거한다.



**상속과 합성(컴포지션)의 차이에 대해서 설명해 주세요.**  

상속은 is a 관계 

컴포지션은 개체들 간에 has a 관계이다. 



상속은 클래스를 확장하여 부모 클래스에서 속성 및 동작을 상속하는 기능입니다. 

자동차는 자동차다.

class Engine{}

abstract class Automobile{}



class car extends Automobile{

​	private Engine engine;

}



합성은 클래스가 구성원 데이터로 다른 클래스의 객체를 포함 할 수있는 능력입니다. 

자동차는 엔진이 포함되어 있다.



**JVM 의 역할은 무엇인지 설명해 보세요.** 

JVM(Java virtual machine)은 자바를 실행하기 위한 가상 기계라고 할 수 있습니다. 여기서 가상 기계란 말이 어색하다면 프로그램을 실행하기 위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것이라고 해석할 수 있습니다. 

JVM은 Java Byte Code를 OS에 맞게 해석해주는 역활을 합니다. Java Compiler가 *.java 파일을 컴피알을 하면 .class라는 java byte code로 변환시켜 주며, Byte Code는 기계어가 아니기 때문에 OS에서 바로 실행이 되지 않습니다. 이 때 JVM이 OS가 이해할 수 있도록 해석해줍니다



**Interface VS abstract**



Interface - 일종의 추상 클래스 - 오직 추상메서드와 상수만을 멤버로 갖는다. - Implements 키워드를 사용 - 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록한다. - Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다. Abstract - 추상메서드를 하나 이상 가진 클래스 - 자신의 생성자로 객체 생성 불가능 - 하위 클래스를 참조하여 상위 클래스의 객체를 생성 - 하위 클래스를 제어하기 위해 사용



**다형성(폴리모피즘, Polymorphism)에 대해서 설명 하여라**

다형성이란 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것을 의미한다.



### 프레임워크를 사용하는 이유는 무엇인가?

개발자는 각각의 실력이나 코딩 방법 등 차이가 큰 편이다. 

그렇다 보니 개발자 구성에 따라 프로젝트의 결과 차이가 많이 생겨서 이러한 것을 극복하기 위해서 프레임워크를 사용하는 것이다. 

구조가 있고, 그 구조 안에 개발자가 코드를 추가하는 형태로 개발을 하는 방식이 프레임워크를 사용한 개발로 일정한 품질이 보장되는 결과물을 얻을 수 있기에 프레임워크를 사용하는 것이다.

 

 

### 왜 스프링 프레임워크가 개발의 대세가 된 것인가?

스프링은 하드웨어적인 구성이 필요없는 경량프레임워크이고, 일반적인 java 클래스와 인터페이스를 이용하는 구조를 사용해서 진입 장법이 낮아서 개발자들이 접근이 쉬웠다고 한다. 그리고, 기본 구조를 흔들지 않고, 여러 종류의 프레임 워크를 혼용해서 사용 할 수 있다.

스프링은 처음에 이해해야 하는 부분은 많지만 결과적으로 코드의 양이 줄어서 개발 생산성이 높고, XML 설정 등을 이용하여 유지보수를 하기 때문에 효율적이다.

 

 

### Spring의 특징은 무엇인가?

POJO 기반 : 자바 코드를 이용해서 객체를 구성하는 방식을 그대로 스프링에서 사용할 수 있음 

의존성 주입 : 메소드나 객체의 호출을 개발자가 아닌 외부에 의해서 결정 함

AOP의 지원 : 보안, 로그, 같은 횡단 관심사를 모듈로 분리하여 공통 기능을 재사용 하도록 돕는 기법 지원

트랜잭션의 지원: 트랜젝션의 처리를 애노테이션이나 XML로 설정할 수 있음

 

 

### DI와 AOP에 대해 설명하시오

DI(Dependency Injection)는 의존성 주입으로 의존적인 객체를 직접 생성하거나 제어하는 것이 아니라 제어의 역행(Ioc)으로 특정 객체에 필요한 객체를 외부에서 결정해서 연결 시키는 것을 의미한다. 이러한 의존성 주입을 스프링은 프레임워크에서 처리하여 개발자는 자신의 코드에 필요한 객체는 스프링을 통해서 주입받는 구조로 작성된다.

DI는 생성자를 통한 주입과 set 메소드를 이용한 주입으로 구분 가능하다.

 

AOP(Aspect Oriented Programing) 관점 지향 프로그래밍, 횡단 관심사의 분리를 허용하여 모듈성을 증가시키는 목적, 대부분의 시스템이 공통으로 가지는 보안, 로그 같은 횡단 관심사를 분리해서 제작하는 것을 말한다.

 

 

### POJO는 무엇인가?

POJO(Plain Old Java Object)는 오래된 방식의 간단한 자바 오브젝트라는 말로, 스프링 전의 프레임워크 등이 무거운 객체를 만드는 것에 반발해서 사용하게 된 용어이다. 

스프링은 객체 간의 관계를 구성할 때 별도의 API를 사용하지 않는 POJO(Plain Old Java Object) 구성으로 제작이 가능하다. 

 

 

### maven에 대해 설명하시오

maven은 프로젝트 관리 도구로 프로젝트의 모든 단계에 사용하는 개발 도구이지만, 가장 많이 사용되는 용도는 프로젝트에 필요한 라이브러리를 자동으로 관리해주는 빌드 도구이다. 필요한 라이브러리 jar파일을 자동으로 다운 받을 수 있다.

Java 기반 프로젝트의 라이프사이클 관리를 위한 빌드 도구로 컴파일과 빌드를 동시에 수행 등 다양한 기능을 한다.

 

 

 

참고로, 잘 모르겠다면 상세하게 설명된 블로그를 보고 오는 것을 추천!

[[Java/Spring\] - Spring STS, Maven 메이븐이란?](https://developsd.tistory.com/69)

[ Spring STS, Maven 메이븐이란?STS는 기본적으로 maven을 내장하고 있다. 프로젝트를 생성하면 바로 maven을 이용해서 스프링 관련 라이브러리가 다운로드 된다. maven하면, pom.xml을 떠올리고, 프로젝트에 필요한 라이브러리를 다운받는 것이..developsd.tistory.com](https://developsd.tistory.com/69)

 

 

### mybatis의 역할은 무엇인가?

mybatis는 개발자가 지정한 SQL, 저장프로시저, 매핑을 지원하는 프레임워크.

이러한 연결 프로그램으로 인해 프로그램 소스코드에서 SQL 문장을 분리하여 별도의 XML 파일로 저장하고 이 둘을 서로 연결 시켜주는 방식으로 작동한다. 

 

 

 

### Spring MVC 구성요소에 대해 설명하시오

Dispatcherservlet

- 클라이언트의 요청을 전달 받아 컨트롤러에게 요청을 전달하고 컨트롤러가 리턴할 결과 값을 view에게 전달하여 알맞은 응답을 하도록 하는 것
- 클라이언트의 요청을 중앙에서 처리하는 스프링 MVC의 핵심 구성 요소
- web.xml에 한개 이상의 DispatcherServlet을 설정한다.

HandlerMapping

- 클라이언트의 요청 URL을 어떤 컨트롤러가 처리할지를 결정

Controller

- 클라이언트의 요청을 처리한 뒤 그 결과를 DispatcherServlet에게 알려준다.

ModelAndView

- 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담아 놓는 세트

ViewResolver

- 컨트롤러의 처리 결과를 생성할 뷰를 결정

View

- 컨트롤러에서 리턴 받은 처리 결과를 화면에 출력한다.

 

 

 

### Spring 기본 환경 설정 파일 및 기능 설명하시오

[파일] root-context.xml : 공통빈을 설정하는곳, view 제외 빈 설정(Dao 등)

[파일] appServlet 폴더 내의 servlet-context.xml

​    servlet 요청과 관련된 객체 정의 파일

​    view페이지 경로 및 파일명 지정

​    bean 설정(베이스 패키지 하위 모든 어노테이션 스캔하여 빈 등록 등)

[파일] web.xml : 환경설정 부분, 배포 서술자,

​           서블릿 이름을 설정하고, 패턴을 설정한다. (.do 패턴 등)

​           filter를 활용하여 encodingFilter 를 추가하여 한글이 깨지지 않도록 설정하기도 한다.

​           각 에러 코드별 error-page를 설정할 수 있다.

​           웹 애플리케이션 요청 시 시작파일을 지정할 수 있다. <welcome-file-list>

[파일] pom.xml : Maven 설정 파일 / 필요한 라이브러리 다운 받는 경우 사용

 

### REST 서비스가 무엇인가?

Representational State Transfer 자원을 이름으로 구분하여 정보를 주고 받는 것

네트워크 상에서 클라이언트와 서버 사이의 통신 방법 중 하나이다. 

XML 파일로 된 웹페이지를 읽어 원하는 정보를 수집하는 기능으로 해당 페이지의 URI만 알면 웹 브라우저로 읽어 정보를 얻을 수 있다. 