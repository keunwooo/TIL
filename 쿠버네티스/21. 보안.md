# ServiceAccount

RBAC를 기반으로 하는 서비스 어카운트 기능

권한을 부여받은 서비스 어카운트는 해당 권한에 해당하는 기능만 사용할 수 있게 된다.



비슷하게 리눅스에서 root 유저와 일반 유저를 나누는 기능을 유사하게 사용이 가능하다.

지금까지 kubectl 명령은 최상위에 해당하는 root와 같은 권한을 가지고 있다.



쿠버네티스의 API에 접근하는 애플리케이션을 운영 환경에 배포하거나, 여러 명의 사용자가 동시에 쿠버네티스를 사용해야 한다면 최상위 권한을 사용하지 않는 것이 좋다.

사용자에게 필요한 최소한의 권한만 부여해서 실행 할수 있는 기능을 제한한다.



1. Role
2. Cluste Role
3. User, Group
4. OIDC



쿠버네티스에는 kube-apiserver, kube-controller, kube-scheduler, etcd 등과 같은 컴포넌트들로 구성되어 있음

kube-apiserver 컴포넌트에 대해서 알아보자.



kubectl apply -f 를 실행하면

kubectl -> HTTP 핸들러 -> Authentication -> Authorization -> Mutating Admission Controller -> Validating Admission Controller -> etcd

kubectl 명령어는 API 서버의 HTTP 핸들러에 요청을 전송.

API 서버는 해당 클라이언트가 쿠버네티스의 사용자가 맞는지 (Authentication) , 해당 기능을 실행할 권한이 있는지 (Authorization) 확인한다.

인증과 인가에는 서드파티 인증(Open ID Connect:OAuth), 인증서 등과 같은 다양한 방법이 사용될 수 있음

Admission Controller라는 별도의 단계를 거친뒤 요청 받은 기능을 수행한다.



처음 설치 시 설치 도구가 자동으로 kubectl이 관리자 권한을 갖도록 설정한다.

```
~/.kube/config
```

에서 확인이 가능하다.



내용 중

users 항목에 인증을 위한 데이터가 설정돼 있음.

```
users:
 - name: name
   user:
    client-certificate=data: ...
    client-key-data: ...
```



client-certificate와 client-key-data에 설정된 데이터는 base64로 인코딩된 인증서이다.

이 키 쌍은 쿠버네티스 최고 권한을 갖는다.

즉, ~/.kube/config 파일에서는 인증서 키 쌍을 사용해 API 서버에 인증하지만, 비교적 절차가 복잡하고 관리하기가 어렵다.



### 서비스 어카운트

서비스 어카운트는 체계적으로 권한을 관리하기 위한 쿠버네티스 오브젝트이다.

서스 어카운트는 한명의 사용자나 애플리케이션에 해당한다고 생각하면 쉽다.

서비스 어카운트는 네임스페이스에 속하는 오브젝트이다.

```
kubectl get sa
kubectl get serviceaccount
```



기본적으로 default 라는 이름의 서비스 어카운트가 존재한다.



서비스 어카운트 생성

```
kubectl create sa user1
```



--as 옵션을 사용하면 임시로 특정 서비스 어카운트를 사용할 수 있다.

```
kubectl get services

kubectl get services --as system:serviceaccount:default:user1
```

system:serviceaccount는 인증을 위해 서비스 어카운트를 사용한다는 의미

default:user1은 default 네임스페이스의 user1 서비스 어카운트를 의미한다.



즉, user1의 서비스 어카운트로 서비스의 목록을 조회한 것이다.

하지만 해당 서비스 어카운트에는 아직 적절한 권한이 부여되어 있지 않기 때문에 에러가 반환된다.



**권한을 부여하는 방법**

1. Role
2. Cluster Role

둘다 부여할 권한이 무엇인지를 나타내는 쿠버네티스 오브젝트이다.

ex) 디플로이먼트를 생성할수 있다도 하나의 롤이 될 수 있고, 서비스의 목록을 조회한다 라는 것도 롤이 될 수 있다.



롤은 네임스페이스에 속하는 오브젝트이다.

그러므로, 디플로이먼트나 서비스처럼 네임스페이스에 속하는 오브젝트들에 대한 권한을 정의할 때 사용한다.



클러스터롤은 클러스터 단위의 권한을 정의할 때 사용한다.

ex) 퍼시스턴트볼륨의 목록을 조회한다

뿐만 아니라, 클러스터 저반에 걸친 기능을 사용하기 위해서도 클러스터롤을 정의할 수 있다.



롤은 네임스페이스에 속하지만, 클러스터 롤은 네임스페이스에 속하지 않는 전역적인 쿠버네티스 오브젝트이다.



현재 네임스페이스의 롤 목록만을 출력

```
kubectl get role
```

클러스터 자체에 존재하는 모든 롤의 목록을 출력한다.

```
kubectl get clusterrole
```



클러스터 롤은 쿠버네티스 컴포넌트가 사용하는 권한도 포함되어 있기 때문에 꽤 많은 수의 클러스터 롤이 미리 생성돼 있다.



롤 작성

```
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
 namespace: default #롤이 생성될 네임스페이스
 name: service-reader #롤의 이름
rules:
- apiGroups: [""] # 대상이 될 오브젝트의 API 그룹
  resources: ["services"] #대상이 될 오브젝트의 이름
  verbs: ["get","list"] # 어떠한 동작을 허용할 것인지 명시
```

apiGroups: 어떠한 API 그룹에 속하는 오브젝트에 대해 권한을 지정할지 설정한다. API 그룹은 쿠버네티스 오브젝트가 가지는 목적에 따라 분류되는 일종의 카테고리이다.  ""는 포드,서비스 등이 포함된 코어 API 그룹을 의미한다.

특정 쿠버네티스 오브젝트가 어떤 API 그룹에 속하는지 확인

```
kubectl api-resources
```

resources: 어떠한 쿠버네티스 오브젝트에 대해 권한을 정의할 것인지 입력한다.

서비스를 다룰수 있는 권한을 정의하기 위해 ["services"] 로 설정함 . resources 항목 또한 kubectl api-resources에 출력되는 오브젝트의 이름을 적절히 사용한다.

verbs: 롤을 부여받은 대상이 resources에 지정된 오브젝트들에 대해 어떤 동작을 수행할 수 있는지 정의한다.

다음과 같은 형태도 가능

```
  resources: ["services"] #대상이 될 오브젝트의 이름
  verbs:
  - get
    list
```



롤을 생성하는 것만으로 서비스 어카운트나 사용자에게 권한이 부여되는 것은 아님.

롤을 특정 대상에게 부여하려면 롤바인딩이라는 오브젝트를 통해 특정 대상과 롤을 연결해야 한다.



롤 바인딩 생성

```
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
 namespace: default #롤이 생성될 네임스페이스
 name: service-reader-rolebinding #롤의 이름
subjects:
- kind: ServiceAccount #권한을 부여할 대상이 ServiceAccount 이다.
  name: user1 #user1이라는 이름의 서비스 어카운트에 권한을 부여한다.
  namespace: default
roleRef:
 kind: Role #Role에 정의된 권한을 부여한다.
 name: service-reader #service-reader라는 이름의 Role을 대상에 연결한다.
 apiGroup: rbac.authorization.k8s.io
 
```



어떠한 대상을 어떠한 롤에 연결할 것인지 정의한다.

subjects 항목에는 서비스 어카운트를

roleRef 항목에는 service-reader 롤을 지정했다.



롤 바인딩과 롤, 서비스 어카운트는 1:1 관계가 아니다.

하나의 롤은 여러 개의 롤 바인딩에 의해 참조될 수도 있고, 하나의 서비스 어카운트는 여러 개의 롤 바인딩에 의해 권한을 부여받을 수도 있다. 

롤은 권한을 부여받기 위한 일종의 템플릿 역할

롤 바인딩은 롤과 서비스 어카운트를 연결하기 위한 중간 다리 역할



특정 리소스에 한정된 기능을 사용할 때는 sub resource를 명시하면 된다.

kubectl exec 명령어로 포드 내부에 들어가기 위한 권한 생성

 pod의 하위 리소스인 pod/exec를 resources에 정의

```
resources: ["pods/exec"]
verbs: ["create"]
```



**클러스터 롤**

 노드와 퍼시스턴트 볼륨 등과 같이 네임스페이스에 종속되지 않는 오브젝트도 존재한다.

클러스터 롤은 클러스터 단위의 리소스에 대한 권한을 정의하기 위해 사용한다.



노드의 목록을 출력하기 위한 클로스터 롤 생성

```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
 namespace: default #롤이 생성될 네임스페이스
 name: nodes-reader
rules:
- apiGroups: [""] # 대상이 될 오브젝트의 API 그룹
  resources: ["nodes"] #대상이 될 오브젝트의 이름
  verbs: ["get","list"] # 어떠한 동작을 허용할 것인지 명시
 
```



클러스터 롤 바인딩

```
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
 namespace: default #롤이 생성될 네임스페이스
 name: service-reader-clusterrolebinding #롤의 이름
subjects:
- kind: ServiceAccount #권한을 부여할 대상이 ServiceAccount 이다.
  name: user1 #user1이라는 이름의 서비스 어카운트에 권한을 부여한다.
  namespace: default
roleRef:
 kind: ClusterRole #Role에 정의된 권한을 부여한다.
 name: nodes-reader #service-reader라는 이름의 Role을 대상에 연결한다.
 apiGroup: rbac.authorization.k8s.io
 
```



---

### 쿠버네티스 API 서버에 접근

서비스 어카운트의 시크릿을 이용해 쿠버네티스 API 서버에 접근



만약 어플리케이션이 쿠버네티스의 API를 사용해야 한다면 일반적으로 kubectl이 아닌 다른 방법으로 API 서버에 접근해야 한다.

API 서버에 접근할 때 어떻게 사용자를 인증하는가



쿠버네티스 API 서버도 HTTP 요청을 통해 쿠버네티스의 기능을 사용할 수 있도록 REST API를 제공하고 있음.

쿠버네티스의 REST API에 접근하기 위한 엔드포인트는 자동으로 개방된다.

쿠버네티스 API는 기본적으로 HTTPS 요청만을 처리하도록 설정되어 있음.

보안 연결을 위해 스스로 사인한 인증서를 사용한다.



```
curl https://localhost:6443/apis -k 
# -k 옵션은 알려지지 않은 인증서를 보안 연결에 사용하겠다는 의미
```

API 서버에 접근하려면 별도의 인증 정보를 HTTP 페이로드에 포함시켜 REST API 요청을 전송해야 한다.

이를 위해 서비스 어카운트를 위한 인증 정보를 시크릿에 저장한다.

서비스 어카운트를 생성하면 이에 대응하는 시크릿이 자동으로 생성된다.

해당 시크릿은 서비스 어카운트를 증명하기 위한 수단으로 사용됨.



```
kubectl describe sa user1
```



서비스 어카운트와 연결된 시크릿에는 ca.crt, namespace, token 총 3개의 데이터가 저장돼 있음

```
kubectl descrbie secret user-token-asfaqw
```

이중 ca.crt는 쿠버네티스 클러스터의 공개 인증서를, namespace는 해당 서비스 어카운트가 존재하는 네임스페이스를 저장하고 있음



token 데이터는 쿠버네티스 API 서버와의 JWT (JSON Web Token) 인증에 사용된다.

따라서 API 서버의 REST API 엔드포인트로 요청을 보낼 때 token의 데이터를 함께 담아서 보내면 나는 user1의 서비스 어카운트다 라는걸 인증할 수 있다.
