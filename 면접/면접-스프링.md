# 스프링

- ### ***\**\*\*\*[ 많은 트래픽이 발생한 경우 대처하는 방법 ]\*\*\*\*\****

   

  - 스케일 업(Scale Up): 서버에 CPU나 RAM 등을 추가하여 서버의 하드웨어 스펙을 향상시키는 방법이다.
  - 스케일 아웃(Scale Out): 서버를 여러 대 추가하여 시스템을 증가시키는 방법이다.

   

  ### ***\**\*\*\*[ CDN(Content Delivery Network)란? ]\*\*\*\*\****

   

  CDN(Content Delivery Network)는 물리적으로 떨어져 있는 사용자에게 컨텐츠를 더 빠르게 제공하기 위해 고안된 기술입니다. 만약 우리나라에 있는 사람이 미국에 있는 서버로부터 이미지나 파일 등을 다운받으려고 하면 시간이 오래 걸립니다. 따라서 느린 응답속도와 다운로드 시간을 극복하기 위해 서버를 분산시켜 캐싱해두고, 빠르게 다운받을 수 있게 합니다.

  CDN은 콘텐츠에 대한 요청이 발생하면 사용자와 가장 가까운 위치에 존재하는 서버로 매핑시켜, 요청된 파일의 캐싱된(사전 저장된) 버전으로 요청을 처리합니다. 서버가 파일을 찾는 데 실패하는 경우 CDN 플랫폼의 다른 서버에서 콘텐츠를 찾은 다음 엔드유저에게 응답을 전송합니다. 



### ***\**\*\*\*[ CORS 란? ]\*\*\*\*\****

CORS(Cross-Origin-Resource-Sharing)란 도메인이 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제입니다. 예를 들어 mangkyu.com에서 mang.com으로 데이터를 요청한다고 하면, 따로 설정을 해주지 않는 한 CORS 에러를 만나게 됩니다.

CORS가 생기게 된 이유는 서버 내에서 요청이 허락된 도메인에만 데이터를 주기 위해서인데, 요청을 허락하기 위해서는 Access-Control-Alow-Origin: {도메인} 과 같은 내용을 Response의 헤더에 추가해주어야 합니다다. 만약 도메인을 *으로 설정하면 모든 도메인에 대해 요청을 허락할 수 있습니다. 그 외에도 Access-Control-Allow-Methods, Access-Control-Max-Age 등을 설정해줄 수 있습니다.

- Access-Control-Allow-Orgin : 요청을 보내는 페이지의 출처 [ *, 도메인 ] 
- Access-Control-Allow-Methods : 요청을 허용하는 메소드. Default : GET, POST
- Access-Control-Max-Age : 클라이언트에서 preflight 요청 (서버의 응답 가능여부에 대한 확인) 결과를 저장할 시간
- Access-Control-Allow-Headers : 요청을 허용하는 헤더

### ***\**\*\*\*[ 아파치는 멀티 프로세스인가 멀티 쓰레드인가? ]\*\*\*\*\****

아파치는 기본적으로 멀티 프로세스로 구현되어 있다. 하지만 설정에 따라 멀티 쓰레드를 같이 운용할 수 있다.

 

 

### ***\**\*\*\*[ 톰캣은 멀티 프로세스인가 멀티 쓰레드인가? ]\*\*\*\*\****

톰캣은 요청을 처리하기 위한 쓰레드 풀을 관리하고 있다. 그리고 요청이 오면 해당 쓰레드 풀에서 쓰레드를 꺼내 요청을 처리하도록 한다.

 

 

### ***\**\*\*\*[ 디자인 패턴 ]\*\*\*\*\****

- 생성 패턴
  - 팩토리 패턴: 객체를 생성하기 위한 디자인 패턴
  - 추상 팩토리 패턴: 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴
  - 빌더 패턴: 상황에 따라 동적인 인자를 필요로 하는 객체를 생성하기 위한 디자인 패턴
  - 싱글톤 패턴: 객체를 1개만 생성하여 항상 참조가능하도록 고안된 디자인 패턴
- 구조 패턴
  - 어댑터 패턴: 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴
  - 프록시 패턴: 어떤 객체에 접근하기 위해 대리인을 사용하는 디자인 패턴
  - 데코레이터 패턴
  - 퍼사드 패턴: 어떤 복합적인 기능에 대해 간략화된 인터페이스를 제공하는 디자인 패턴
- 행위 패턴
  - 전략 패턴: 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴
  - 옵저버 패턴: 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴
  - 커맨드 패턴: 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴

DatabaseController=> SingletonPattern을 사용하여 데이터베이스를 제어하는 하나의 인스턴스만을 생성

DatabasePool => ObjectPool Pattern을 사용하여 데이터베이스 객체를 미리 생성하여 Performance 향상

UnitFactory => FactoryPattern을 사용하여 객체 생성을 최적화 + Singleton Pattern을 사용하여 하나의 공장을 사용

BaseFrame => ObserverPattern을 사용하여 사용자의 정보가 생신되면 View의 값들도 갱신되게 함

PlayerInfo => StrategyPattern을 사용하여 상황에 따라 다른 스킬을 사용

 

 

### ***\**\*\*\*[ Servlet(서블릿)이란? ]\*\*\*\*\****

서블릿이란 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술입니다. Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환합니다.

 

 

### ***\**\*\*\*[ Spring 기초지식(DI, DL, IoC, AOP) ]\*\*\*\*\****

- DI(Dependency Injection): 한 객체에서 다른 객체를 필요로 하여 의존성을 갖게 하는 기술
- DL(Dependency Look-up): 한 객체에서 필요로 하는 다른 객체를 찾아서 사용하는 기술
- IoC(Inversion of Control): 직접 제어야하는 부분에 대한 권한을 프레임워크 등에 넘기는 기술
- AOP(Aspect Oriented Programming): 공통의 관심 사항을 추출하여 원하는 곳에 적용하는 기술

 

 

### ***\**\*\*\*[ VO와 BO, DAO란? ]\*\*\*\*\****

- VO(Value Object): 실제 데이터만을 저장하는 클래스, DTO라고도 부름
- DAO(Data Access Object): DB에 접근하여 실제 데이터를 조회 또는 조작하는 클래스, Repository 또는 Mapper에 해당함
- BO(Business Object): 여러 DAO를 활용해 비지니스 로직을 처리하는 클래스, Service에 해당함



### ***\**\*\*\*[ 디스패처 서블릿(Dispatcher Servlet)이란? ]\*\*\*\*\****

디스패처 서블릿이란 톰캣과 같은 서블릿 컨테이너를 통해 들어오는 모든 요청을 제일 앞에서 받는 컨트롤러입니다. 디스패처 서블릿은 공통된 작업을 처리한 후에, 적절한 세부 컨트롤러로 작업을 위임해줍니다. 그리고 각각의 세부 컨트롤러는 처리할 부분을 처리하고 반환할 view를 Dispatcher Servlet에 넘기게 됩니다.



### ***\**\*\*\*[ Spring에서의 싱글톤 패턴 ]\*\*\*\*\****

싱글톤 패턴은 1개의 클래스당 1개의 객체만을 생성하여 사용하는 디자인 패턴입니다. Spring에서는 스프링 컨테이너가 관리하는 객체인 Bean을 싱글톤패턴으로 구현하여 제공합니다.(당연히 스코프를 변경할 수 있습니다.)

Java의 싱글톤은 해당 클래스로더 내에서 1개의 인스턴스만을 생성할 수 있지만, Spring에서는 스프링 컨테이너의 컨텍스트에서 1개의 인스턴스를 생성할 수 있습니다. 그에 따라 Java의 싱글톤은 JVM에 라이프사이클의 제어가 되지만, Spring의 싱글톤은 스프링 컨텍스트에 의해 제어가 된다. 또한 Spring에서의 싱글톤은 Thread Safety를 자동으로 보장하는 반면 Java로 구현한 싱글톤 패턴은 반드시 보장하지 못합니다.

 

 

### ***\**\*\*\*[ MVC 패턴이란? ]\*\*\*\*\****

MVC(Model-View-Controller)패턴은 아키텍쳐를 설계하기 위한 디자인 패턴입니다. 

MVC 패턴은 애플리케이션을 개발할 때 그 구성요소를 3가지로 나눕니다.

- Model: 데이터를 저장하는 컴포넌트
- View: 사용자 인터페이스(UI) 컴포넌트
- Controller: 사용자의 요청을 처리하고 Model과 View를 중개하는 컴포넌트



### ***\**\*\*\*[ Spring MVC란? ]\*\*\*\*\****

Spring MVC란 웹 애플리케이션 개발을 위한 MVC 패턴 기반의 웹 프레임워크입니다. Spring MVC는 애플리케이션의 구성요소를 Model, View, Controller로 분리합니다. 또한 Spring MVC는 아래와 같은 컴포넌트들로 구성됩니다.

- Dispatcher Servlet: 클라이언트의 요청을 먼저 받아들이는 서블릿으로, 요청에 맞는 컨트롤러에게 요청을 전달함
- Handler Mapping: 해당 요청이 어떤 컨트롤러에게 온 요청인지 검사함
- Controller: 클라이언트의 요청을 받아 처리하여 결과를 디스패처 서블릿에게 전달함
- ViewResolver: View의 이름을 통해 알맞은 View를 찾음
- View: 사용자에게 보여질 UI 화면

 

### ***\**\*\*\*[ Spring MVC의 장점과 단점 그리고 SpringBoot]\*\*\*\*\****

- 장점
  - 의존성 주입을 통해 컴포넌트 간의 결합도를 낮출 수 있어 단위테스트가 용이함
  - 제어의 역전을 통해 빈(객체)의 라이프싸이클에 관여하지 않고 개발에 집중할 수 있음
- 단점
  - XML을 기반으로 하는 프로젝트 설정은 너무 많은 시간을 필요로 함
  - 톰캣과 같은 WAS를 별도로 설치해주어야 함
- 해결책(Spring Boot)
  - 자동설정(AutoConfiguration)을 도입하여 Dispatcher Servlet 등과 같은 설정 시간을 줄여줌
  - 프로젝트의 의존성을 독립적으로 선택하지 않고 spring-boot-starter로 모아두어 외부 도구들을 사용하기 편리함
  - 내장 톰캣을 제공하여 별도의 WAS를 필요로 하지 않음 



정적 동적 

WAS vs WS

### N+1 쿼리

N+1 Problem은 쿼리 1번으로 N건의 데이터를 가져왔는데 원하는 데이터를 얻기 위해 이 N건의 데이터를 데이터 수 만큼 반복해서 2차적으로 쿼리를 수행하는 문제다. 이 문제의 해결방식으로 Eager-Loading방식이 있다.



#### 1. 스프링 프레임워크란?

- 자바 앤터프라이즈 개발을 편리하게 해주는 경량급 오픈소스 애플리케이션 프레임워크
- POJO기반의 Enterprise Application 개발을 쉽고 편하게 할 수 있도록 한다.
- Java Application을 개발하는데 필요한 하부구조를 포괄적으로 제공하기때문에 개발자는 Application 개발에 집중할 수 있다.
- 대한민국 공공기간의 웹 서비스 개발시 사용을 권장하고 있는 전자 정부 표준 프레임워크의 기반 기술이다.



#### 2. Container란?

- 컨테이너는 보통 instance의 Life Cycle을 관리하며, 생성된 인스턴스에게 추가적인 기능을 제공하도록 하는 것이다. 다시 말해, 컨테이너란 작성한 코드의 처리과정을 위임받은 독립적인 존재라고 생각하면 된다.
- 컨테이너는 적절한 설정만 되어있다면, 누구의 도움없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤 해준다.

#### 3. IOC란?

- IoC(Inversion of Control)이란, 객체의 생성부터 Life Cycle 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미 합니다. 또는 제어권한이 다른 대상에게 위임하는 것입니다. (여기서 다른 대상은 Servlet과 같은  Bean을 관리해주는 container)
- 이 방식은 대부분의 프레임워크에서 사용하는 방법으로, 개발자는 필요한 부분을 개발해서 끼워넣기의 형태로 개발하고 실행하게 됩니다. 프레임워크가 이러한 구조를 가지기 때문에 개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식의 개발을 하게 된다.



#### 4. Framework와 Library의 차이?

- IoC의 개념이 적용되었나의 차이
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
- 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.



#### 5. DI (Dependency Injection)

- **DI 란?**
  - Dependency Injection은 Spring Framework에서 지원하는 IoC의 형태이다.
  - DI는 클래스 사이의 의존관계를 Bean 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것을 말한다. 개발자들은 제어를 담당할 필요없이 Bean 설정 파일에 의존관계가 필요하다는 정보만 추가해주면 된다. 
  - 컨테이너가 실행 흐름의 주체가 되어 Application 코드의 의존관계를 주입해주는 것
- **의존성이란**?
  - 현재 객체가 다른 객체와 상호작용하고 있다면 다른 객체들을 현재 객체의 의존이라 한다.
- **의존성이 위험한 이유**
  - 하나의 모듈이 바뀌면 의존하고 있는 다른 모듈까지 변경되어야 한다.
  - 테스트 가능한 어플을 만들 때 의존성이 있으면 유닛테스트 작성이 어렵다.
  - 유닛테스트의 목적 자체가 다른 모듈로부터 독립적으로 테스트하는 것을 요구한다.
- **DI의 특징**
  - 'new'를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.
  - 의존성 주입은 IoC 개념을 바탕으로 한다. 클래스가 외부로부터 의존성을 가져야한다.
- **DI가 필요한 이유**
  - 클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할 수 있다.
  - 비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적
- **DI의 세가지 방법**
  - Contructor Injection : 생성자 삽입
  - Method(Setter) Injection: 메소드 매개 변수 삽입
  - Field injection : 맴버 변수 삽입

#### 6. AOP란 ? 

- Aspect Oriented Programming 관점 지향 프로그래밍의 약자

- 기존의 OOP에서 기능별로 class를 분리했음에도 불구하고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트, 등 처럼 공통적으로 반복되는 중복코드 ( 횡단 관심사 ) 가 나오는 단점을 해결하고자 나온 방식 

- 개발코드에서는 비지니스 로직에 집중하고 실행시 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로써 중복 코드를 줄일 수 있는 방법

   

#### 7. POJO란?

- 번역하면 '평범한 구식 자바 객체', 즉 Framework Interface나 class를 구현하거나 확장하지 않은 단순한 클래스.
- 특징
  - Java에서 제공하는 API 외에 종속되지 않음
  - 특정 규약, 환경에 종속되지 않음
- 환경에 종속되지 않는 것의 장점
  - 코드의 간결함 (비즈니스 로직과 특정 환경/Low 레벨 종속적인 코드를 분리하므로 단순)
  - 비즈니스 로직과 특정 환경이 분리되므로 단순함
  - 자동화 테스트에 유리 (환경 종속적인 코드는 자동화 테스트가 어렵지만, POJO는 테스트가 유연)

#### 8. DAO란? 

- DB에 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체를 말한다.
- DB에 접근을 하기 위한 로직과 비즈니스 로직을 분리하기 위해서 사용한다.



#### 9. VO란?

- 계층간 데이터 교환을 위한 자바빈즈를 말한다. 

  (여기서 말하는 계층은 Controller, View Business, Persistent Layer)

- 일반적인 VO는 로직을 가지고 있지 않은 순수한 데이터 객체이며, 속성과 그 속성에 접근하기 위한 getter, setter 메소드만 가진 클래스이다.

- DTO 라고도 불린다.



#### 10. JDBC란?

- Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍

#### 11. Mybatis란 ?

- 객체, 데이터베이스, 매퍼 자체를 독립적으로 작성하고 DTO에 해당하는 부분과 SQL실행결과를 SQL문등에 매핑해서 사용할 수 있도록 지원
- 스프링이나 JDBC를 통해 작업하던 dao에 관련된 작업은 모두 sql문이 자바 소스상에 위치했었으나 이제 sql문은 설정파일로 관리한다.
- 설정파일로 분리되면 변경되거나 했을때 설정파일만 건드리면 되므로 유지보수에 좋다. 또한, 매개변수나 리턴타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업한다



#### 12. MVC 패턴에 대해 설명해보세요

**MVC란?**

\- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,

\- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

**MVC 구성요소**

**Model** - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 **논리적 데이터 기반 구조를 표\****현**. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

**View** - 사용자 인터페이스 내의 구성요소들을 표현(**사용자에게 보여지는 화면**)

**Controller** - Model과 View를 연결하고 있는 클래스를 대표, **Model과 View 내의 클래스들 간 정보 교환**하는데 사용.

















#### Spring MVC 처리 순서**

1. 클라이언트(Client)가 서버에 어떤 요청(Request)을 한다면 스프링에서 제공하는 **DispatcherServlet** 이라는 클래스(일종의 front controller)가 요청을 가로챈다.
2. (web.xml에 살펴보면 모든 url ( / )에 서블릿 매핑을하여 모든 요청을 DispatcherServlet이 가로채게 해둠(변경 가능))
3. 요청을 가로챈 DispatcherServlet은 **HandlerMapping**(URL 분석등..)에게 어떤 컨트롤러에게 요청을 위임하면 좋을지 물어본다. (servlet-context.xml에서 @Controller로 등록한 것들을 스캔해서 찾아준다.)
4. 요청에 매핑된 컨트롤러가 있다면 @RequestMapping을 통하여 요청을 처리할 메서드에 도달한다.

\4. 컨트롤러에서는 해당 요청을 처리할 Service를 주입(DI)받아 비즈니스로직을 Service에게 위임한다.

\5. Service에서는 요청에 필요한 작업 대부분(코딩)을 담당하며 데이터베이스에 접근이 필요하면 DAO를 주입받아 DB처리는 DAO에게 위임한다.



\6. DAO는 mybatis(또는 hibernate등) 설정을 이용해서 SQL 쿼리를 날려 DB의 정보를 받아 서비스에게 다시 돌려준다.

(이 때 보통 VO(dto)를 컨트롤러에서 부터 내려받아 쿼리의 결과를 VO에 담는다. (mybatis의 resultType) 

\7. 모든 로직을 끝낸 서비스가 결과를 컨트롤러에게 넘긴다.

\8. 결과를 받은 컨트롤러는 Model객체에 결과물 어떤 view(jsp)파일을 보여줄 것인지등의 정보를 담아 DispatcherServlet에게 보낸다.

\9. DispatcherServlet은 ViewResolver에게 받은 뷰의 대한 정보를 넘긴다.

\10. ViewResolver는 해당 JSP를 찾아서(응답할 View를 찾음) DispatcherServlet에게 알려준다.

(servlet-context.xml에서 suffix, prefix를 통해 /WEB-INF/views/index.jsp 이렇게 만들어주는 것도 ViewResolver)

\11. DispatcherServlet은 응답할 View에게 Render를 지시하고 View는 응답 로직을 처리한다.

\12. 결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다. -->



**★ 스프링 프레임워크의 특징에 관해 설명하라****.**

 

**① Portable Service Abstraction(서비스 추상화)**

트랜젝션 추상화, OXM 추상화, 데이터 액세스의 Exception 변환기능 등 

기술적인 복잡함은 추상화를 통해 Low Level의 기술구현부분과 기술을 사용하는

인터페이스로 분리한다.

 

**② 객체 지향과 DI(Dependency Injection)**

Spring은 객체지향에 충실한 설계가 가능하도록 단순한 객체형태로 개발할 수 있고,

DI는 유연하게 확장 가능한 객체를 만들어 두고 그 관계는 외부에서 다이내믹하게 설정해준다.

 

**③ AOP(Aspect Oriented Programming)**

AOP는 애플리케이션 로직을 담당하는 코드에 남아있는 기술 관련 코드를 분리해서

별도의 모듈로 관리하게 해주는 강력한 기술이다.

 

**④ POJO(Plain Old Java Object)**

POJO는 객체지향 원리에 충실하면서, 특정 환경이나 규약에 종속되지 않고 필요에 따라 재활용될수 있는

방식으로 설계된 객체이다.

####  

####  

**★** **SpringMVC의 정의 및 동작방식?**

 

**<정의>**

 



![img](https://blog.kakaocdn.net/dn/QfSzK/btqCqNKsa8R/ukbHUwXMBy0vPf8krvoyGk/img.png)



MVC 는 Model, View, Controller의 약자

하나의 애플리케이션, 프로젝트를 구성할 때 그 구성요소를 세가지의 역할로 구분한 패턴.

사용자가 controller를 조작하면 controller는 model을 통해서 데이터를 가져오고

그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 됨.

 

> **모델, Model**
>
> 애플리케이션의 정보, 데이터를 나타냄. 
> 데이터베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻함
> 또한 이러한 데이터, 정보들의 가공을 책임지는 컴포넌트

 

> **뷰, View**
>
> 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당.
> input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소.

 

> **컨트롤러,Controller**
>
> 데이터와 사용자인터페이스 요소들을 잇는 다리역할.
> 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분.

 

 

 

**<동작방식>**



![img](https://blog.kakaocdn.net/dn/sEIaK/btqCbhF1Yuk/cvjWwadOiTJKMYFk3Iwcbk/img.png)



 

\1. DispatcherServlet이 브라우저로부터 요청을 받는다.

 

\2. DispatcherServlet은 요청된 URL을 HandlerMapping 객체에 넘기고,

  호출해야 할 Controller 메소드(핸들러) 정보를 얻는다.

 

\3. DispatcherServlet이 HandlerAdapter 객체를 가져온다. 

 

\4. HandlerAdapter 객체의 메소드를 실행한다. 

 

\5. Controller 객체는 비즈니스 로직을 처리하고, 그 결과를 바탕으로 뷰(ex. JSP)에 전달할 객체를

  Model 객체에 저장한다. DispatcherServlet에게 view name을 리턴한다.

 

\6. DispatcherServlet은 view name을 View Resolver에게 전달하여 View 객체를 얻는다.

 

\7. DispatcherServlet은 View 객체에 화면 표시를 의뢰한다.

 

\8. View 객체는 해당하는 뷰(ex. JSP, Thymeleaf)를 호출하며,

  뷰는 Model 객체에서 화면 표시에 필요한 객체를 가져와 화면 표시를 처리한다.

 

 

 

**★** **Map과 List의 차이점**

**1) Map: '키-값' 의 쌍으로 나열되어 있어 키값을 통해 원하는 값을 한번에 찾아낼 수 있다.**

빈번한 검색과, 범위데이터가 아닌 특정 데이터를 순간마다 캐치해야할 때 유리한 자료구조

 

Map을 이용해 저장할때는 List처럼 뭉텅이로 저장하는것이 아니라,

Map에 아이템을 저장할때마다, 빈 공간을 찾아 저장한다.

따라서 List보다는 데이터 저장속도가 느릴 수 있다. Map의 가장 큰 특징이라면,

쌍을이루는 Key와 Value값을 이용한다는 것이다.

따라서 단순한 포지션(0~10 같은 인덱션)보다는, 저장하고 싶은 데이터가 특별한 Key값을

가질때 Map을 사용하는것이 좋다.

 

동일한 Key값을 사용하면 기존의 Key값을 가지고 있는 value가 사라지고

후에 저장한 valuse 값이 셋팅이 된다. key만 다르다면 value 값이 중복되도 상관 없다.

Map은 콘솔에 찍힌거와 같이 키값이 의미가 있을때 좋은 자료구조 이다.

ArrayList안에 원하는 데이터를 검색하는 경우에는 0번부터 해당 데이터가 있을때까지

검색을 해야하지만, (원하는 데이터의 index를 모르는 경우) hashMap의 경우는 

key값을 통해서 빠르게 데이터를 검색한다. 

요소의 추가 삭제는 List보다 성능이 나을때가 많다. 따라서, 검색성능은 기본적으로 Map이 좋다.

 

 

**2) List : 순차적으로 데이터를 저장하거나 엑세스 할때 사용.**

원하는 데이터 범위를 순차적으로 표현할때 유리한 자료구조

 

ArrayList안에 있는 데이터를 삽입/삭제가 빈번할때, 비효율적인 경우가 있다.

추가는 단순히 ArrayList 내부 배열의 크기를 바꾸고 기존 배열의 데이터를 추가하는데 그치지만,

원하는 포지션(인덱스)의 삽입/삭제는 이야기가 다르다. 

 

삽입/ 삭제는 해당 포지션 아래의 데이터들을 Copy 해야한다. 

(새로운 배열을 만든후,기존 배열의 값을 포지션별로 다시 채워야한다.)

기존 배열의 크기를 늘린후 삽입/삭제 데이터를 처리하고 Copy된 데이터를 다시 붙인다.

따라서 ArrayList의 size가 큰 경우는 많은 양의 요소들을 Copy해야 하므로 내부적으로 성능이

떨어질 수 있다.

 

 

 

**- 상속이란 무엇이고, 상속의 단점은?** 

상속이란 부모 클래스가 가지고있는 모든것을(생성자 제외) 자식클래스가 물려받아 같이 공유하며 나아가 확장(extends)하는 개념이다. 부모 클래스를 상위 클래스(superclass)로 부르며 상속받는 자식 클래스를 하위클래스(subclass)라고 부른다.

 

상속의 단점으로는,

\1. 하위 클래스는 상위 클래스의 부분집합이기 때문에 상위 클래스가 변경이 일어나면 하위 클래스도 따라서 변형되기 때문에, 상속은 상위 클래스가 기능의 버그와 기능의 추가/변경 등으로 변화가 생겼을 때 상위 클래스를 상속받은 하위 클래스가 정상 동작할지를 예측하기 힘들다.

\2. 기능 확장에 따라 상위 클래스에서 파생된 많은 클래스들이 생겨나는데 규모가 커질수록 매우 다양한 클래스들이 존재하고 이 클래스들을 일관성있게 만들지 않으면 사용자는 이해하고 사용하는데 많은 어려움이 생긴다.



→ 클래스간 결합 관계(필요한 기능들을 클래스 필드에 두어 그 기능들을 적절히 사용하여 새로운 기능을 구현하는 방식)를 이용해 해결한다. 



 

**- class와 instance는 무엇인가?**


클래스는 객체를 만들어 내기 위한 설계도 혹은 틀
연관되어 있는 변수와 메서드의 집합



인스턴스는 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체이다. 즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다. 자바의 경우 new로 메모리에 할당해서 사용한다

 

 

 

**- thread란? thread를 구현하기 위한** **인터페이스, 클래스는?**

스레드(thread)란 프로세스(process) 내에서 실제로 작업을 수행하는 주체를 의미합니다.

모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행.

 

쓰레드 구현을 위한 두가지 방법

\1. Runnable 인터페이스를 구현하는 방법

\2. Thread 클래스를 상속받는 방법

 

 

**- static 키워드에 대해 설명하라.**

클래스를 이용하여 객체를 생성할 때, 각각의 객체들은 자신만의 멤버 변수를 가진다.

각각의 객체는 이들 변수에 대하여 별도의 기억 공간을 가지고 있는데,

static 키워드를 이용하여 선언한 변수는 해당 클래스의 모든 객체들에 의해 공유된다.

 

 

**- 오버로딩과 오버라이딩의 차이점은?**

오버로딩 : 같은 이름의 메소드를 여러개 가지면서 매개 변수를 다르게 정의하는 것.

오버라이딩 : 부모클래스가 갖고 있는 메소드를 자식클래스에서 재정의해 사용하는 것.

 

 

**- 추상클래스와 인터페이스에 대해 설명하라.**

추상클래스는 클래스 내 추상메소드가 하나 이상 포함 되어있거나 abstract로 정의된 경우를 말한다.

반면 인터페이스는 모든 메소드가 추상 메소드인 경우이다.

 

추상클래스는 그 추상클래스를 상속받아서 기능을 이용하고 확장하는데에 있고,

인터페이스는 함수의 껍데기만 있는데, 그 함수의 구현을 강제하기 위해서이다.

 

 

**- MVC패턴 대해 동작방식을 설명하라.**

\1. 사용자는 원하는 기능을 처리하기 위한 모든 요청을 컨트롤러에 보낸다.

\2. 컨트롤러는 모델을 사용하여 알맞은 비즈니스 로직을 수행한다.

\3. 사용자에게 보여줄 뷰를 선택한다.

\4. 선택된 뷰는 사용자에게 알맞는 결과 화면을 보여준다. 이 때 사용자에게 보여줄 데이터는 컨트롤러를 통해서 전달받는다.

 

 

**- model1과 model2 패턴의 차이를 설명하라.**

model1은 뷰와 로직을 모두 JSP페이지 하나에서 처리하는 구조를 말하며

model2는 JSP페이지와 서블릿, 그리고 로직을 위한 클래스가 나뉘어 브라우저 요청을 한다.

 

 

 

**- JSTL은 무엇이고 사용하는 이유는 무엇인가?**

JSP 표준 태그 라이브러리의 약어로써, 자신만의 태그를 추가할 수 있는 기능을 제공한다.

주로 JSTL의 core에서 c를 사용하여 <c:if> <c:forEach> 등으로 사용한다.

 

 

 

**- JSP에서 세션에 값을 저장하고 꺼내는 방법은 무엇인가?**

\1. session.setAttribute(String name, Object value);

\- 세션에 값을 저장하기 위해 셋어트리뷰트를 이용해 세션에 저장될 특정값을 지정한다.

\- name이 바로 세션에 저장된 특정 값을 찾아오기 위한 키로 사용된다.

\- 이 키와 일대일 대응으로 저장하고 싶은 값을 value 위치에 지정한다.

 

\2. Object getAttribute(String name)
\- 세션에 저장된 값을 얻어오기 위해 getAttribute 메소드를 사용한다.



 

 

**- JSP에서 한글이 깨지는 문제가 발생시 어떻게 해야 하나?**

\1. JSP 페이지 1번 줄에 셋팅

<%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%>

 

 

\2. post 방식의 파라미터를 받는 페이지마다 해당 라인 추가

request.setCharacterEncoding("utf-8");

 

 

\3. 톰캣 server.xml 파일에 Connector마다 URIEncoding="utf-8" 추가

<connector uriencoding="utf-8" connectiontimeout="20000" port="8080" protocol="HTTP/1.1" redirectport="8443">

</connector>

 

 

\4. 톰캣 web.xml 파일 수정

<filter>

  <filter-name>setCharacterEncodingFilter</filter-name>

  <filter-class>org.apache.catalina.filters.SetCharacterEncodingFilter</filter-class>

  <init-param>

​    <param-name>encoding</param-name>

​    <param-value>UTF-8</param-value>

  </init-param>

  <async-supported>true</async-supported>

</filter>

 

 

 

**- JSP는 무엇인가?**

JSP 란 JavaServer Pages 의 약자이며

HTML 코드에 JAVA 코드를 넣어 동적웹페이지를 생성하는 웹어플리케이션 도구이다.

JSP 가 실행되면 자바 서블릿(Servlet) 으로 변환되며 웹 어플리케이션 서버에서 동작되면서 필요한 기능을 수행하고

그렇게 생성된 데이터를 웹페이지와 함께 클라이언트로 응답한다.

 

 

 

**- Servlet이란 무엇인가?**

서블릿이란 웹페이지를 동적으로 생성하기 위해 서버측 프로그램을 말한다. 

이는 자바 언어를 기반으로 만들지며 웹 어플리케이션 서버 ( Web Application Sever ) 위에서 컴파일 되고 동작한다.

 

JSP 와 서블릿의 차이점은 결과적으로 하는일은 동일하지만 

JSP 는 HTML 내부에 JAVA 소스코드가 들어감으로 인해 HTML 코드를 작성하기 간편하다는 장점이있으며

서블릿은 자바코드내에 HTML 코드가 있어서 읽고 쓰기가 굉장히 불편하기 때문에 작업의 효율성이 떨어진다.





 

**- Ajax란 무엇인가?**

AJAX란, JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml (비동기식 자바스크립트와 xml) 의 약자이다. 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법

 

JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술이며,

쉽게 말해 자바스크립트를 통해서 서버에 데이터를 요청하는 것이다.

 

 

**- JSON이란 무엇인가?**

JSON은 JavaScript Object Notation 의 줄임말로 말 그대로 자바스크립트에서 객체를 표현하는 방법입니다.

 

원래는 자바스크립트 언어에서 객체를 정의할 때 사용하는 문법, 규칙이었는데, key-value 방식으로 데이터를 표현하거나 이해하는데 직관적이고 규칙도 간단하여 여러 언어나 통신에서 사용됨.

JSON은 네이버나 구글같은 플랫폼 기업에서 제공하는 공개 API에서도 XML과 같이 사용되고 있음.

거의 대부분의 언어에서 자체적으로 JSON을 다룰 수 있는 API를 제공하거나

자체 API가 없더라도 오픈 소스 라이브러리를 제공하는 추세.

 

참고: GSON은 JSON구조를 띄는 직렬화된 데이터를 JAVA의 객체로 역직렬화, 직렬화 해주는 자바 라이브러리이다.

즉, JSON Object -> JAVA Object 또는 그 반대의 행위를 돕는 라이브러리.

 

 

**- RESTful이 무엇인가?**

RESTful이란 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이며,

이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것에 목적이 있다.
그러므로 ‘REST API’를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있다.

 

여기서 REST는 “Representational State Transfer” 의 약자이고,
자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미한다.

REST API는 REST 기반으로 설계 기본규칙에 따라 서비스 API를 구현한 것이다.
(/: 계층관계, -:가독성위해사용, uri 경로에는 소문자를 쓰며 _는 사용하지 않는다 등...) 


최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.

 

사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.

즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.

 

 

 

**- 세션과 쿠키의 차이점은 무엇인가?**

\- 세션: 일정 시간동안 같은 브라우저로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 유지하는 기술

\- 쿠키: 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일이다.

 

**- 쿠키와 세션의 차이:**

 

\1. 저장위치: 쿠키는 클라이언트에 파일로 저장, 세션은 서버에 저장

 

\2. 보안: 쿠키는 클라이언트 로컬에 저장되기 때문에 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋다.

 

\3. 라이프 사이클: 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.

반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.

 

\4. 속도: 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

 

\* 세션을 주로 사용하면 좋은데 왜 쿠키를 사용할까?

세션은 서버의 자원을 사용하기때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문.

 

\* 쿠키,세션은 캐시와 엄연히 다르다.

캐시는 이미지나 css, js파일 등이 사용자의 브라우저에 저장이 되는 것이다.

이를 이용해 자원이 아껴지는 것, 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데, 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있다.

 

 

 

- **MVC란?**

  MVC 는 Model, View, Controller의 약자

  Model은 가공된 데이터 등 어떤 동작에 수행하는 코드를 뜻하고, View는 사용자에게 보여지는 화면, Controller는 데이터의 입력 등을 처리와 흐름제어를 담당하는 3개지 역확로 구분한 패턴 입니다.

 

- **MVC 패턴 모델 1, 2의 차이점**

  model1은 뷰와 로직을 모두 JSP페이지 하나에서 처리하는 구조를 말하며

  model2는 JSP페이지와 서블릿, 그리고 로직을 위한 클래스가 나뉘어 브라우저 요청을 한다.

 

- **모델1 구조는 사용자의 요청을 JSP가 전부 다 처리.**

  웹브라우저 사용자의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용하여 웹브라우저가 요청한 작업을 처리하고 그 결과를 출력.

  **모델 2 구조는 모델 1구조와 달리 웹브라우저 사용자의 요청을 서블릿이 받음.**

  서블릿은 웹브라우저의 요청을 받아 View로 보여줄것인지 Model로 보내줄것인지 정하여 전송. 여기서 View페이지는 사용자에게 보여주는 역할만 담당하고 실질적인 기능의 부분은 Model에서 담당.

  MVC1 Pattern

  https://t1.daumcdn.net/cfile/tistory/99E8D5395BD5971D25

  하지만 이러한 로직은 추후 유지보수시 Controller와 View와 같이 있다보니 소스가 지저분하고 고치기에 다소 걸리고

  동료가 하던 것을 넘겨받아서 유지보수를 할 시 에는 소스보기에도 힘든 면이 있고 분석하고 다시 고치기에 시간이 걸립니다.

  MVC2 Pattern

  \* **모듈화** : 소프트웨어를 부품화 시킨다는 개념.

  예를들어, 모든 소스가 한곳에 다 적혀서 만들어진 웹 어플리케이션이라면 추후 유지보수 시 찾는 것도 힘들고 재활용하기에도 힘들것 입니다. 하지만, 모듈화를 한다면 DB관련 따로 View화면 따로, 이 두개를 관리하는 곳도 따로 관리한다면 유지보수시 에러가 난 곳을 쉽게 찾아가서 수정가능하고 업데이트 시에도 해당 파일만 건드리면 되기에 유지보수가 쉽습니다.

  https://t1.daumcdn.net/cfile/tistory/99C3243D5BD59D4507

  사용자 화면에 데이터가 필요한 과정이라면 이러한 로직이 수행될 것입니다.

  또한, View 단이 꼭 jsp로 하는 것은 아니지만, 표현하기 쉽기 때문에 jsp파일로 많이 표현합니다.

  그리고 Model 역시 java 파일로 많이 표현합니다.

  Model1 과 Model2에서 작업속도는 Model1 이 더 빠를 수 있겠지만, 추후 시간이 흐르고 프로젝트가 커졌을 경우 유지보수 및 관리 측면에서 Model2 방식이 효율이 훨씬 뛰어날것입니다.

 

- MVC에서 Model, View, Controller 가 모두 **모듈화** 되어 있는 형태이다. ( 규모가 크고 추후 유지보수 시 개발이 자주 일어날 수 있는 경우에 사용. )

 

- MVC에서 View와 Controller 가 같이 있는 형태이다. ( 규모가 작고 유지보수 보단 빨리 개발할 때 사용. )

 

 

- **스프링 특징**

  ① **"경량 컨테이너"**(크기와 부하의 측면)로서 자바 객체를 직접 관리

  - 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.

  ② **제어 역행**(**IoC** : Inversion of Control)

  - 애플리케이션의 느슨한 결합을 도모.
  - 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출한다.

  ③ **의존성 주입**(**DI** : Dependency Injection)

  - 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

  개발자가 주체가 되는 것이 아니라 컨테이너가 주체가 되어서 코드의 의존관계가 되는 것으로 annotation을 통해서 코드가 단순해지고 실행 시 동적으로 의존관계가 생성된다.

  ③ **관점지향 프로그래밍**(**AOP** : Aspect-Oriented Programming)

  - 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 **공통적으로 사용하는 기능의 경우 해당 기능을 분리**하여 관리할 수 있다.

  ④ 애플리케이션 객체의 생명 주기와 설정을 포함하고 관리한다는 점에서 일종의 **"컨테이너"**(Container)라고 할 수 있다.

  - iBatis, myBatis나 Hibernate 등 완성도가 높은 데이터베이스처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.

  ⑤ **트랜잭션 관리** 프레임워크

  - 추상화된 트랜잭션 관리를 지원하며 설정파일(xml, java, property 등)을 이용한 선언적인 방식 및 프로그래밍을 통한 방식을 모두 지원한다.

  ⑥ **모델-뷰-컨트롤러** 패턴

  - 웹 개발 시 거의 표준적인 방식인 **"Spring MVC"**라 불리는 모델-뷰-컨트롤러(MVC) 패턴을 사용한다.

  \- DispatcherServlet이 Controller 역할을 담당하여 각종 요청을 적절한 서비스에 분산시켜주며 이를 각 서비스들이 처리를 하여 결과를 생성하고 그 결과는 다양한 형식의 View 서비스들로 화면에 표시될 수 있다.

 

- **AJAX에 대해서, 동기 비동기식의 차이점**

  Ajax를 이용하면 사용자가 서버에 자료를 요청할 때 화면 전환 없이 요청한 자료를 전송받을 수 있음.

  또한 자료를 요청할 경우 어느정도 시간이 소요되는데 반해 Ajax는 기다릴 필요 없이 바로 수행 가능.

  - 어떤 루틴을 완전히 끝내고 제어를 반납하면 **동기식**
  - 동작이 안 끝났어도 일단 제어권을 반납한 후 지 할일 계속하면 **비동기식**

 

- **SpringFramework의 주요 백엔드 기술은?**

  객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는

  개발 프레임 워크로써, JDBC를 통해 데이터베이스에 엑세스 하는 작업을 캡슐화하고

  일반 SQL 쿼리, 저장 프로 시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을

  제거 합니다. Mybatis에서는 프로그램에 있는 SQL쿼리들을 한 구성파일에 구성하여 프로그램 코드와

  SQL을 분리할 수 있는 장점이 있음.

 

- **Mybatis의 정의와 쓰는 이유**

  객체 지향 언어인 자바의 관계형 데이터베이스 프로그래밍을 좀 더 쉽게 할 수 있게 도와 주는

  개발 프레임 워크로서, JDBC를 통해 데이터베이스에 엑세스하는 작업을 캡슐화하고

  일반 SQL 쿼리, 저장 프로 시저 및 고급 매핑을 지원하며 모든 JDBC 코드 및 매개 변수의 중복작업을

  제거 합니다. Mybatis에서는 프로그램에 있는 SQL쿼리들을 한 구성파일에 구성하여

  프로그램 코드와 SQL을 분리할 수 있는 장점

 

- **Spring툴을 사용하면서 Service와 Dao를 나누어 사용하는 이유**

  **DAO** - 단일 데이터의 접근과 갱신만 처리한다(CRUD)

  **Service** - 여러 DAO를 호출하여 사용자의 요구에 맞게 가공한다.

  DAO는 단일 데이터 접근/갱신만 처리합니다.Service는 여러 DAO를 호출하여 여러번의 데이터 접근/갱신을 하며 그렇게 읽은 데이터에 대한 비즈니스 로직을 수행하고, 그것을 하나의(혹은 여러개의) 트랜잭션으로 묶습니다.

 

- **AOP 특징 설명**

  **Aspect Oriented Programming**의 약자 **관점 지향 프로그래밍**이라고 불린다.

  **어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다**

 

- **HTTP 메소드 종류에 대해서 설명 및 GET ,POST의 차이**

  **[GET](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/GET):** GET 메서드는 특정 리소스의 표시를 요청. GET 사용 요청은 오직 데이터를 받기만 함.

  **[POST](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/POST):** POST 메서드는 특정 리소스에 엔티티를 제출할 때 쓰임. 종종 서버의 상태의 변화나 부작용을 일으킴.

  **[HEAD](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/HEAD):** HEAD 메서드는 GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않는다.

  **[PUT](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/PUT):** PUT 메서드는 목적 리소스 모든 현재 표시를 요청 payload로 바꿈

  **[DELETE](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/DELETE):** DELETE 메서드는 특정 리소스를 삭제.

  **[CONNECT](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/CONNECT):** CONNECT 메서드는 목적 리소스로 식별되는 서버로의 터널을 맺음.

  **[OPTIONS](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/OPTIONS):** OPTIONS 메서드는 목적 리소스의 통신을 설정하는 데 쓰임.

  **TRACE:** TRACE 메서드는 목적 리소스의 경로를 따라 메시지 loop-back 테스트를 함.

  **[PATCH](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/PATCH)**: PATCH 메서드는 리소스의 부분만을 수정하는 데 쓰인다.

  - **GET 방식**

    - **클라이언트가 입력한 query의 이름과 값이 결합되어 스트링 형태로 서버에 전달**됩니다.
    - <FORM> TAG의 METHOD 속성의 값으로 GET을 입력합니다.

    ex) <FORM NAME="form1" ACTION="index.jsp" METHOD="GET">

  - **POST 방식**

    - **클라이언트와 서버 간에 인코딩하여 서버로 전송**합니다.
    - 헤더를 통해 요청이 전송되는 방식입니다.
    - <FORM> TAG의 METHOD 속성의 값으로 POST을 입력합니다.

    ex) <FORM NAME="form1" ACTION="index.jsp" METHOD="POST">

 

- **forward 와 redirect 차이**

  **[ Forward 방식 ]**

  Forward는 Web Container 차원에서 페이지의 이동만 존재합니다. 실제로 웹 브라우저는 다른 페이지로 이동했음을 알 수 없습니다. 그렇기 때문에 웹 브라우저에는 최초에 호출한 URL이 표시되고, 이동한 페이지의 URL 정보는 확인할 수 없습니다. 또한 현재 실행중인 페이지와 forward에 의해 호출될 페이지는 Request 객체와 Response 객체를 공유합니다.

  **[ Redirect 방식 ]**

  Redirect는 Web Container로 명령이 들어오면, 웹 브라우저에게 다른 페이지로 이동하라고 명령을 내립니다. 그러면 웹 브라우저는 URL을 지시된 주소로 바꾸고 해당 주소로 이동합니다. 다른 웹 컨테이너에 있는 주소로 이동하며 새로운 페이지에서는 Request와 Response객체가 새롭게 생성됩니다.

 

- **session과 cookie 설명 둘이 다른점**

  - **세션**: 일정 시간동안 같은 브라우저로 부터 들어오는 요구들을 하나의 상태로 보고 그 상태를 유지하는 기술.
  - **쿠키**: 클라이언트 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일.

  **- 쿠키와 세션의 차이:**

  **1. 저장위치:** 쿠키는 클라이언트에 파일로 저장, 세션은 서버에 저장

  **2. 보안:** 쿠키는 클라이언트 로컬에 저장되기 때문에 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋다.

  **3. 라이프 사이클:** 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.

  반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.

  **4. 속도:** 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

  - 세션을 주로 사용하면 좋은데 왜 쿠키를 사용할까?

  세션은 서버의 자원을 사용하기때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문.

  - 쿠키,세션은 캐시와 엄연히 다르다.

  캐시는 이미지나 css, js파일 등이 사용자의 브라우저에 저장이 되는 것이다.

  이를 이용해 자원이 아껴지는 것, 한번 캐시에 저장되면 브라우저를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데, 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있다.

 

- **플랫폼, 프레임워크, 라이브러리 차이점**

  - **Platform** : **소프트웨어SW를 실행해주는 환경.** Windows, Linux 등의 OS가 예이다.

  - **Framework** : Software Framework. **클래스와 라이브러리들의 집합**이라고 생각하자. 여기에서 라이브러리랑은 뭐가 달라요?라는 의문이 생긴다.

  - **LIbrary**는 **개발자가 프로그램의 흐름을 제어**한다. 주가 개발자이다.

    그러나, **Framework는 그 반대**이다. 프레임워크의 실행 흐름 내에서 개발자가 일부분을 개발한다.



**1) 자바의 특징에 대해 말해보시오.**

1) OOP(객체 지향 언어) 

: 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법

2) "가비지 컬렉션"에 의한 메모리 자동 관리

3) "멀티 쓰레드"를 지원한다.

4) JVM 위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며, 보안성이 좋다.

5) 다양한 Open 라이브러리들이 존재한다.





**2) 자바를 만든 사람에 대해 아시나요?**

: "제임스 고슬링"





**3) 변수란?**

: "하나의 값을 저장할 수 있는 메모리 공간"





**4) 객체와 클래스의 차이점에 대해 설명해 보시오.**

\- 클래스(Class) : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것으로 "아직 메모리가 할당되지 않은 상태"

vs

\- 객체(Object) : 이 Class라는 설계도를 기반으로 실제 메모리가 잡힌 것을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해

  나가는 방식을 OOP(객체지향 프로그래밍)이라고 한다.





**5) 객체 지향 PG이란? 또 그 특징은?**

: 현실세계의 객체를 필드와 메서드로 정의한 Class를 기반으로 실제 메모리가 잡혀 만들어진 부품과 같은 객체들을 조합해

 전체 프로그램을 완성해 나가는 개발 기법으로

특징)

\- 캡슐화, 은닉화 : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 있는 getter/setter 메서드를 통해 접근하도록 하는 방식

\- 상속 : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식

\- 다형성 : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질

등을 들 수 있다.





**6) 다형성이란?**

: 서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질





**7) 자바의 메모리 영역(간단하게 설명)**

\1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.

  , 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.

\2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리

\3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.





**8) 추상메서드? 추상 클래스?**

\- 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드

\- 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기

​    때문에 객체화 할 수 없다.





**9) 인터페이스(Interface)란? 또 왜 사용하나?**

: 인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로

 정의가 된다. 또한 변수도 자동으로 final static 키워드가 붙게 된다.



왜 인터페이스를 사용하는가? 

: 팀작업시 개발코드 부분과 객체가 서로 통신하는 접점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부 구조를 모르더라도 인터페이스의

 메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의

 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다.

 또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collections.sort()를 하기 위해서 Comparable 인터페이스를 

 상속하는 것, Cloneable 을 구현하는 것처럼 특정 작업을 하겠다라는 "Mark"역할을 해주기도 한다.





**10) 프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?**

\- 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에

  서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.

\- 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의

 자원(메모리)는 프로세스 내에서 공유하게 된다.





**11) 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.**



\- Collection 인터페이스 

\- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.

ex) - ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를

옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.

  \- LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만

연결하면 되기 때문에 삽입, 삭제에 유리하다.

  \- Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리

Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

\- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우

 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.

ex) - HashSet

  \- TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

  



\- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.

ex) - HashMap

   \- TreeMap

   \- Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.

   \- Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

**12) 쿠키(Cookie)와 세션(Session)의 공통점과 차이점은?**

\- 공통점 : 둘 다 사용자의 데이터를 저장한다.

\- 차이점

\- 쿠키: 쿠키는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.

\- 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.



**13) Request 전송 방식에는 어떤 것들이 있는지 아시나요?**

\- Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.

\- POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.

\- DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.

\- PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.





**14) RESTFUL이란?**

: 해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식





**15) Spring에서 DI란 무엇인지 아시나요?**

: DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.

 DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 

 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때, 

 Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.





**16) Spring의 AOP란?**

: AOP는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하

 고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드 처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로

 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에

 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.





**17) Filter와 Interceptor 방식의 차이?**

: 





**18) 디자인 패턴 아는 것?**

1) 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우

 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.

2) 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는

  생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.

3) 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로

  사용됩니다.





**19) MVC 패턴이란?**

\- Model : data 처리와 접근을 담당

\- View : Client에 보여지는 화면을 담당

\- Controller : Model과 View를 제어

하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.





**20) 프로젝트 개발 순서??**

대강...

1) 요구사항 분석 

기획 및 스토리 보드 작성

2) WBS(Work Breakdown Structure) 작성 : 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도

3) 논리 ERD 작성

4) 물리 ERD 작성

5) 개발

6) Testing

7) 유지보수





**21) 오버로딩과 오버라이딩의 차이?**

\- 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식

\- 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식



**22) Servlet vs JSP**

\- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것

\- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



**23) Wrapper Class의 사용이유를 아나요?**

: 기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로

 넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며

 최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.





**24) DataBase에서 Index란?**

: Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.





**25) private, protected, public, default 제어자에 대해 설명해 보시오**

\- private : 같은 class 내부에서"만" 접근이 가능하다.

\- public : 어디서든 자유롭게 접근이 가능하다.

\- protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.

\- default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.





**26) SI가 무엇을 하는 건지 알고 오셨나요?**

: System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.





**27) SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?**

: Testing 부분입니다. 





**28) 자바의 제네릭이란??**

: 클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식

자바의 특징에 대해 말해보시오.

1) OOP(객체 지향 언어)
: 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해 전체 프로그램을 완성하는 개발 기법
2) "가비지 컬렉션"에 의한 메모리 자동 관리
3) "멀티 쓰레드"를 지원한다.
4) JVM 위에서 동작하기 때문에 특정 OS에 종속적이지 않고 이식성이 좋으며, 보안성이 좋다.
5) 다양한 Open 라이브러리들이 존재한다.



자바를 만든 사람에 대해 아시나요?

"제임스 고슬링"



변수란?

"하나의 값을 저장할 수 있는 메모리 공간"



객체와 클래스의 차이점에 대해 설명해 보시오.

\- 클래스(Class) : 현실 세계의 객체의 속성과 동작을 추려내 필드와 메서드로 정의한 것으로 "아직 메모리가 할당되지 않은 상태"
vs
\- 객체(Object) : 이 Class라는 설계도를 기반으로 실제 메모리가 잡힌 것을 의미하며 이런 객체를 조합해 전체 프로그램을 완성해
나가는 방식을 OOP(객체지향 프로그래밍)이라고 한다.



객체 지향의 특징은?

\- 캡슐화, 은닉화 : 외부 객체에서 구현방식은 알 수 없도록 숨기고 별도로 접근할 수 있는 getter/setter 메서드를 통해 접근하도록 하는 방식
\- 상속 : 부모 Class를 자식이 접근할 수 있도록 물려 받는 방식
\- 다형성 : 부모 클래스 타입으로 해당 부모를 상속받는 여러 자식 class를 대입할 수 있는 성질
등을 들 수 있다.



객체지향프로그램이란 ?

프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍



객체 지향 프로그래밍의 장, 단점 간단하게 설명해주세요

\- 장점
▶코드 재사용이 용이
남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있음.
▶유지보수가 쉬움
절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 멤버 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됨.
▶대형 프로젝트에 적합
클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 분담하기 쉽다.

\- 단점
▶처리속도가 상대적으로 느림
▶객체가 많으면 용량이 커질 수 있음
▶설계시 많은 시간과 노력이 필요



클래스와 인스턴스(객체)는 무엇인지 설명해주세요.

클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의한 것

인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터



객체지향프로그래밍에서 추상화 (자료의 추상화)

불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.



캡슐화가 무엇인가요?

캡슐화의 목적 : 코드를 재수정 없이 재활용하는 것.
프로그램 코드에서 변수와 함수를 재활용하기에는 분산되어 있기 때문에 재활용이 어려웠으나 캡슐화를 통해 관련된 기능과 특성을 한 곳에 모으고 분류하기 때문에 재활용이 원활해졌다.



자바의 메모리 영역(간단하게 설명)

\1. 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다.
, 코드에서 사용되는 class들을 로더로 읽어 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장한다.
\2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리
\3. 힙(Heap) : new 연산자를 통한 동작할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.



추상메서드? 추상 클래스?

\- 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
\- 추상 클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다.



인터페이스(Interface)란? 또 왜 사용하나?

인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 정의가 된다. 또한 변수도 자동으로 final static 키워드가붙게 된다.



프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?

\- 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는IPC(InterProcess Communication)과 같은 방식이 필요하다.
\- 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의
자원(메모리)는 프로세스 내에서 공유하게 된다.



컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.

\- List 인터페이스 : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
\- Set 인터페이스 : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
\- Map 인터페이스 : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.



쿠키(Cookie)와 세션(Session)의 공통점과 차이점은?

\- 쿠키: 쿠키는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
\- 세션 : 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.



Request 전송 방식에는 어떤 것들이 있는지 아시나요?

\- Get 방식 : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
\- POST 방식 : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
\- DELETE 방식 : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
\- PUT/PUSH 방식 : RESTFUL에서 수정 작업을 할 때 주로 사용된다.



RESTFUL이란?

해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식



Spring에서 DI란 무엇인지 아시나요?

DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IOC 컨테이너의 구체적인 구현 방식입니다.
DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는
별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다. 이때,
Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.



Spring의 AOP란?

어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다. 여기서 모듈화란 어떤 공통된 로직이나 기능을 하나의 단위로 묶는 것을 말한다.
Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한 것. 주로 부가기능을 모듈화함.
Target : Aspect를 적용하는 곳 (클래스, 메서드 .. )
Advice : 실질적으로 어떤 일을 해야할 지에 대한 것, 실질적인 부가기능을 담은 구현체



디자인 패턴 아는 것?

1) 싱글톤(SingleTone Pattern) : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.
2) 팩토리 패턴(Factory pattern) : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.
3) 옵저버 패턴(Observer Pattern) : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로 사용됩니다.



싱글톤 패턴(Singleton Pattern)

애플리케이션이 시작될 때 어떤 클래스가 최초 한번만 메모리를 할당하고(Static) 그 메모리에 인스턴스를 만들어 사용하는 디자인패턴.생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.



MVC 패턴이란?

\- Model : data 처리와 접근을 담당
\- View : Client에 보여지는 화면을 담당
\- Controller : Model과 View를 제어
하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.



프로젝트 개발 순서??

요구사항분석 -> 개발 -> 설계 -> 테스트



오버로딩과 오버라이딩의 차이?

\- 오버로딩 : 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식
\- 오버라이딩 : 상속한 자식에서 부모의 메서드를 재정의하는 방식



Servlet vs JSP

\- Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
\- JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것



Wrapper Class의 사용이유를 아나요?

기본 data 타입은 객체가 아니어서 Object로 받는 다형성을 지원할 수가 없다. 하지만, 메서드에서 실재로 기본데이터 타입을 다형성으로
넘겨주어야 하는 경우가 빈번히 발생하는데 이때, 기본 데이터 타입을 객체로 변환시켜 전달하기 위해 사용되며
최근에는 AUTO Boxing, AUTO UnBoxing이 지원된다.



DataBase에서 Index란?

Table에 대한 동작 속도를 높여주는 자료구조로서 빠른 검색을 가능하게 해준다.



private, protected, public, default 제어자에 대해 설명해 보시오

\- private : 같은 class 내부에서"만" 접근이 가능하다.
\- public : 어디서든 자유롭게 접근이 가능하다.
\- protected : 같은 class 내부 + 상속받은 자식에서는 부모 class에 접근이 가능하다.
\- default : 아무 것도 선언하지 않은 경우로 같은 패키지 내부에서만 접근이 가능하다.



SI가 무엇을 하는 건지 알고 오셨나요?

System Integration의 약자로 시스템 통합 사업으로 고객의 기존 전산시스템을 통합하거나 새로운 시스템을 구축하는 작업입니다.



SW 개발시 가장 비중을 크게 두어야 할 부분은 어디라고 생각하나요?

Testing 부분입니다.



자바의 제네릭이란??

클래스 내부에서 사용할 데이터 타입을 인스턴스(객체) 생성시에 결정짓는 방식



64bit CPU와 32bit CPU의 OS적 관점에서의 차이를 설명해 보시오.

CPU와 메모리가 한번에 전송할 수 있는 데이터 크기
64bit CPU에는 32bit / 64bit 운영체제를 둘 다 설치할 수 있는데, 다만 32bit 운영체제를 설치하면 32bit 모드로 동작하게 됩니다.



'데드락' 이란 무엇이고 이를 해결하기 위한 방법을 설명해 보시오.

한정된 자원을 여러 곳에서 사용하려고 할 때 발생할 수 있다.
발생조건 : 상호배제, 비선점, 점유와대기,환형대기
해결방법 : 예방,회피, 회복,무시



웹 서버와 WAS

웹 서버는 정적인 컨텐츠( html, css, js )를 제공하는 서버입니다.
WAS는 DB 조회나, 어떤 로직을 처리해야 하는 동적인 컨텐츠를 제공하는 서버입니다.



변수 명명법

변수에 공백이나 특수문자($이나 _를 제외)를 사용할 수 없다
Camel 캐이싱
두문을 소문자로 시작
단어 사이의 단락을 대문자로 표기한다.



자바 프로그램 특징

1.자바프로그램은 운영체제에 독립적이다.
2.객체지향 언어이기 때문에 유지보수가 용이하다.
3.자동으로 메모리관리를 해준다.
4.동적 로딩을 지원한다.
5.오픈소스 자료가 풍부하다.
6.자바프로그램은 안정적이다.



톰캣 환경설정을 잡는 것

내컴퓨터 우클릭 -> 속성 -> 고급 -> 환경변수 선택 합니다.
변수이름:CATALINA_HOME
변수값: C:\tools\tomcat8
Path 선택 후 편집 -> 맨 앞에

%CATALINA_HOME%\bin;

를 추가 합니다.



jquery /json /ajax

jQuery : javascript 기반으로 만들어진 라이브러리
json은 key: value로 구성된 자바스크립트의 객체표현에서 따온 일종의 데이터의 열거방식
ajax비동기식 서버 전송&수신.비동기식은 서버에 요청했을 경우, 화면단에서는 다른 작업을 할 수 있지만,



개발시에 중요하다 생각하는 요소를 3가지

\1. 사용자 관점에서의 사용성
\2. 완성도
\3. 자원효율성



'에자일' 방법론

협력,피드백
협력과 피드백을 자주! 일찍! 더 잘하는 것!"



스프링 환경설정

\1. STS 설치
\2. 톰캣 설치
\3. [New] - [Spring Legacy Project]
4.Templates 에서는 Spring MVC Project
5.패키지를 작성
6.pom.xml 을 클릭하여 스프링 버전과 자바 버전을 수정해야 한다.



캐시 (Cache)

리소스 파일들의 임시 저장소. 같은 웹 페이지에 접속할 때 사용자의 PC에서 로드하므로 서버를 거치지 않아도 된다.



객체 지향 프로그래밍

컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "객체"들의 모임으로 파악하고자 하는 것이다. 각각의 객체는 메시지를 주고받고, 데이터를 처리할 수 있다.



Framework

개발할 때 설계 기본이 되는 뼈대나 구조 / 환경



스프링 특징

② 제어 역행(IoC : Inversion of Control)
\- 애플리케이션의 느슨한 결합을 도모.
\- 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출한다.

③ 의존성 주입(DI : Dependency Injection)
\- 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.

③ 관점지향 프로그래밍(AOP : Aspect-Oriented Programming)
\- 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.
출처:https://goddaehee.tistory.com/156[갓대희의 작은공간]



인터페이스는 무엇인가?

모든 메소드가 추상 메소드이고, 일반 변수를 가질 수 없다. (추상 클래스와 비교해보자)
인터페이스를 상속하기 위해서는 implements 키워드를 사용한다.
추상 클래스를 상속하기 위해서 extends 키워드를 사용한다.
인터페이스를 상속받은 경우는 모든 메소드를 구현해줬다.
반면에 추상 클래스를 상속받은 경우는 일반 메소드가 아닌 추상 메소드만을 구현했다.
인터페이스 협업에서 이점을 갖는다.



멀티쓰레드의 장점

1.응답성이 좋음
2.자원공유 효율적
3.작업분리 코드 간결

단점
1.구현하기 어려움
2.교착상태에 주의